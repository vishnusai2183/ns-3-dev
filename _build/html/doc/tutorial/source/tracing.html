<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>8. Tracing &#8212; ns-3 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=039e1c02" />
    <script src="../../../_static/documentation_options.js?v=f2a433a1"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <style>.param {font-weight:bold; color:#602020;}</style><section id="tracing">
<h1><span class="section-number">8. </span>Tracing<a class="headerlink" href="#tracing" title="Link to this heading">¶</a></h1>
<section id="background">
<h2><span class="section-number">8.1. </span>Background<a class="headerlink" href="#background" title="Link to this heading">¶</a></h2>
<p>As mentioned in <a class="reference internal" href="tweaking.html#usingtracingsystem"><span class="std std-ref">Using the Tracing System</span></a>, the whole point
of running an <em>ns-3</em> simulation is to generate output for study.  You
have two basic strategies to obtain output from <em>ns-3</em>: using generic
pre-defined bulk output mechanisms and parsing their content to
extract interesting information; or somehow developing an output
mechanism that conveys exactly (and perhaps only) the information
wanted.</p>
<p>Using pre-defined bulk output mechanisms has the advantage of not
requiring any changes to <em>ns-3</em>, but it may require writing scripts to
parse and filter for data of interest.  Often, PCAP or <code class="docutils literal notranslate"><span class="pre">NS_LOG</span></code>
output messages are gathered during simulation runs and separately run
through scripts that use <code class="docutils literal notranslate"><span class="pre">grep</span></code>, <code class="docutils literal notranslate"><span class="pre">sed</span></code> or <code class="docutils literal notranslate"><span class="pre">awk</span></code> to parse the
messages and reduce and transform the data to a manageable form.
Programs must be written to do the transformation, so this does not
come for free.  <code class="docutils literal notranslate"><span class="pre">NS_LOG</span></code> output is not considered part of the <em>ns-3</em>
API, and can change without warning between releases.  In addition,
<code class="docutils literal notranslate"><span class="pre">NS_LOG</span></code> output is only available in debug builds, so relying on it
imposes a performance penalty.  Of course, if the information of
interest does not exist in any of the pre-defined output mechanisms,
this approach fails.</p>
<p>If you need to add some tidbit of information to the pre-defined bulk
mechanisms, this can certainly be done; and if you use one of the
<em>ns-3</em> mechanisms, you may get your code added as a contribution.</p>
<p><em>ns-3</em> provides another mechanism, called Tracing, that avoids some of
the problems inherent in the bulk output mechanisms.  It has several
important advantages.  First, you can reduce the amount of data you
have to manage by only tracing the events of interest to you (for
large simulations, dumping everything to disk for post-processing can
create I/O bottlenecks).  Second, if you use this method, you can
control the format of the output directly so you avoid the
postprocessing step with <code class="docutils literal notranslate"><span class="pre">sed</span></code>, <code class="docutils literal notranslate"><span class="pre">awk</span></code>, <code class="docutils literal notranslate"><span class="pre">perl</span></code> or <code class="docutils literal notranslate"><span class="pre">python</span></code>
scripts.  If you desire, your output can be formatted directly into a
form acceptable by gnuplot, for example (see also
<a class="reference internal" href="data-collection.html#gnuplothelper"><span class="std std-ref">GnuplotHelper</span></a>).  You can add hooks in the core which can then
be accessed by other users, but which will produce no information
unless explicitly asked to do so.  For these reasons, we believe that
the <em>ns-3</em> tracing system is the best way to get information out of a
simulation and is also therefore one of the most important mechanisms
to understand in <em>ns-3</em>.</p>
<section id="blunt-instruments">
<h3><span class="section-number">8.1.1. </span>Blunt Instruments<a class="headerlink" href="#blunt-instruments" title="Link to this heading">¶</a></h3>
<p>There are many ways to get information out of a program.  The most
straightforward way is to just print the information directly to the
standard output, as in:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="p">...</span>
<span class="kt">void</span>
<span class="n">SomeFunction</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SOME_INTERESTING_VALUE</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;The value of x is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Nobody is going to prevent you from going deep into the core of <em>ns-3</em>
and adding print statements.  This is insanely easy to do and, after
all, you have complete control of your own <em>ns-3</em> branch.  This will
probably not turn out to be very satisfactory in the long term,
though.</p>
<p>As the number of print statements increases in your programs, the task
of dealing with the large number of outputs will become more and more
complicated.  Eventually, you may feel the need to control what
information is being printed in some way, perhaps by turning on and
off certain categories of prints, or increasing or decreasing the
amount of information you want.  If you continue down this path you
may discover that you have re-implemented the <code class="docutils literal notranslate"><span class="pre">NS_LOG</span></code> mechanism
(see <a class="reference internal" href="tweaking.html#usinglogging"><span class="std std-ref">Using the Logging Module</span></a>).  In order to avoid that, one of the first
things you might consider is using <code class="docutils literal notranslate"><span class="pre">NS_LOG</span></code> itself.</p>
<p>We mentioned above that one way to get information out of <em>ns-3</em> is to
parse existing <code class="docutils literal notranslate"><span class="pre">NS_LOG</span></code> output for interesting information.  If you
discover that some tidbit of information you need is not present in
existing log output, you could edit the core of <em>ns-3</em> and simply add
your interesting information to the output stream.  Now, this is
certainly better than adding your own print statements since it
follows <em>ns-3</em> coding conventions and could potentially be useful to
other people as a patch to the existing core.</p>
<p>Let’s pick a random example.  If you wanted to add more logging to the
<em>ns-3</em> TCP socket (<code class="docutils literal notranslate"><span class="pre">tcp-socket-base.cc</span></code>) you could just add a new
message down in the implementation.  Notice that in
<code class="docutils literal notranslate"><span class="pre">TcpSocketBase::ProcessEstablished()</span></code> there is no log message for the
reception of a SYN+ACK in ESTABLISHED state.
You could simply add one, changing the code.  Here is the original:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Received a packet upon ESTABLISHED state. This function is mimicking the</span>
<span class="cm">    role of tcp_rcv_established() in tcp_input.c in Linux kernel. */</span>
<span class="kt">void</span>
<span class="nf">TcpSocketBase::ProcessEstablished</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">packet</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">&amp;</span><span class="w"> </span><span class="n">tcpHeader</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">NS_LOG_FUNCTION</span><span class="p">(</span><span class="k">this</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tcpHeader</span><span class="p">);</span>
<span class="w">  </span><span class="p">...</span>

<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tcpflags</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">SYN</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">ACK</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="c1">// No action for received SYN+ACK, it is probably a duplicated packet</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">...</span>
</pre></div>
</div>
<p>To log the SYN+ACK case, you can add a new <code class="docutils literal notranslate"><span class="pre">NS_LOG_LOGIC</span></code> in the
<code class="docutils literal notranslate"><span class="pre">if</span></code> statement body:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Received a packet upon ESTABLISHED state. This function is mimicking the</span>
<span class="cm">    role of tcp_rcv_established() in tcp_input.c in Linux kernel. */</span>
<span class="kt">void</span>
<span class="nf">TcpSocketBase::ProcessEstablished</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">packet</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">&amp;</span><span class="w"> </span><span class="n">tcpHeader</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">NS_LOG_FUNCTION</span><span class="p">(</span><span class="k">this</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tcpHeader</span><span class="p">);</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tcpflags</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">SYN</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">ACK</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="c1">// No action for received SYN+ACK, it is probably a duplicated packet</span>
<span class="w">      </span><span class="n">NS_LOG_LOGIC</span><span class="p">(</span><span class="s">&quot;TcpSocketBase &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="k">this</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; ignoring SYN+ACK&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">...</span>
</pre></div>
</div>
<p>This may seem fairly simple and satisfying at first glance, but
something to consider is that you will be writing code to add
<code class="docutils literal notranslate"><span class="pre">NS_LOG</span></code> statements and you will also have to write code (as in
<code class="docutils literal notranslate"><span class="pre">grep</span></code>, <code class="docutils literal notranslate"><span class="pre">sed</span></code> or <code class="docutils literal notranslate"><span class="pre">awk</span></code> scripts) to parse the log output in order
to isolate your information.  This is because even though you have
some control over what is output by the logging system, you only have
control down to the log component level, which is typically an entire
source code file.</p>
<p>If you are adding code to an existing module, you will also have to
live with the output that every other developer has found interesting.
You may find that in order to get the small amount of information you
need, you may have to wade through huge amounts of extraneous messages
that are of no interest to you.  You may be forced to save huge log
files to disk and process them down to a few lines whenever you want
to do anything.</p>
<p>Since there are no guarantees in <em>ns-3</em> about the stability of
<code class="docutils literal notranslate"><span class="pre">NS_LOG</span></code> output, you may also discover that pieces of log output
which you depend on disappear or change between releases.  If you depend
on the structure of the output, you may find other messages being
added or deleted which may affect your parsing code.</p>
<p>Finally, <code class="docutils literal notranslate"><span class="pre">NS_LOG</span></code> output is only available in debug builds, you
can’t get log output from optimized builds, which run about twice as
fast.  Relying on <code class="docutils literal notranslate"><span class="pre">NS_LOG</span></code> imposes a performance penalty.</p>
<p>For these reasons, we consider prints to <code class="docutils literal notranslate"><span class="pre">std::cout</span></code> and <code class="docutils literal notranslate"><span class="pre">NS_LOG</span></code>
messages to be quick and dirty ways to get more information out of
<em>ns-3</em>, but not suitable for serious work.</p>
<p>It is desirable to have a stable facility using stable APIs that allow
one to reach into the core system and only get the information
required.  It is desirable to be able to do this without having to
change and recompile the core system.  Even better would be a system
that notified user code when an item of interest changed or an
interesting event happened so the user doesn’t have to actively poke
around in the system looking for things.</p>
<p>The <em>ns-3</em> tracing system is designed to work along those lines and is
well-integrated with the <a class="reference internal" href="tweaking.html#attribute"><span class="std std-ref">Attribute</span></a> and <a class="reference internal" href="#config"><span class="std std-ref">Config</span></a> subsystems allowing for relatively simple use scenarios.</p>
</section>
</section>
<section id="overview">
<h2><span class="section-number">8.2. </span>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h2>
<p>The <em>ns-3</em> tracing system is built on the concepts of independent
tracing sources and tracing sinks, along with a uniform mechanism for
connecting sources to sinks.</p>
<p>Trace sources are entities that can signal events that happen in a
simulation and provide access to interesting underlying data.  For
example, a trace source could indicate when a packet is received by a
net device and provide access to the packet contents for interested
trace sinks.  A trace source might also indicate when an interesting
state change happens in a model.  For example, the congestion window
of a TCP model is a prime candidate for a trace source.  Every time
the congestion window changes connected trace sinks are notified with
the old and new value.</p>
<p>Trace sources are not useful by themselves; they must be connected to
other pieces of code that actually do something useful with the
information provided by the source.  The entities that consume trace
information are called trace sinks.  Trace sources are generators of
data and trace sinks are consumers.  This explicit division allows
for large numbers of trace sources to be scattered around the system
in places which model authors believe might be useful.  Inserting
trace sources introduces a very small execution overhead.</p>
<p>There can be zero or more consumers of trace events generated by a
trace source.  One can think of a trace source as a kind of
point-to-multipoint information link.  Your code looking for trace
events from a particular piece of core code could happily coexist with
other code doing something entirely different from the same
information.</p>
<p>Unless a user connects a trace sink to one of these sources, nothing
is output.  By using the tracing system, both you and other people
hooked to the same trace source are getting exactly what they want and
only what they want out of the system.  Neither of you are impacting
any other user by changing what information is output by the system.
If you happen to add a trace source, your work as a good open-source
citizen may allow other users to provide new utilities that are
perhaps very useful overall, without making any changes to the <em>ns-3</em>
core.</p>
<section id="simple-example">
<h3><span class="section-number">8.2.1. </span>Simple Example<a class="headerlink" href="#simple-example" title="Link to this heading">¶</a></h3>
<p>Let’s take a few minutes and walk through a simple tracing example.
We are going to need a little background on Callbacks to understand
what is happening in the example, so we have to take a small detour
right away.</p>
<section id="callbacks">
<h4><span class="section-number">8.2.1.1. </span>Callbacks<a class="headerlink" href="#callbacks" title="Link to this heading">¶</a></h4>
<p>The goal of the Callback system in <em>ns-3</em> is to allow one piece of code
to call a function (or method in C++) without any specific
inter-module dependency.  This ultimately means you need some kind of
indirection – you treat the address of the called function as a
variable.  This variable is called a pointer-to-function variable.
The relationship between function and pointer-to-function is
really no different that that of object and pointer-to-object.</p>
<p>In C the canonical example of a pointer-to-function is a
pointer-to-function-returning-integer (PFI).  For a PFI taking one <code class="docutils literal notranslate"><span class="pre">int</span></code>
parameter, this could be declared like,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">pfi</span><span class="p">)(</span><span class="kt">int</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>(But read the <a class="reference external" href="http://www.parashift.com/c++-faq/pointers-to-members.html">C++-FAQ Section 33</a> before
writing code like this!)  What you get from this is a variable named
simply <code class="docutils literal notranslate"><span class="pre">pfi</span></code> that is initialized to the value 0.  If you want to
initialize this pointer to something meaningful, you need to have a
function with a matching signature.  In this case, you could provide a
function that looks like:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">MyFunction</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
</pre></div>
</div>
<p>If you have this target, you can initialize the variable to point to
your function:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">pfi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyFunction</span><span class="p">;</span>
</pre></div>
</div>
<p>You can then call MyFunction indirectly using the more suggestive form
of the call:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">pfi</span><span class="p">)(</span><span class="mi">1234</span><span class="p">);</span>
</pre></div>
</div>
<p>This is suggestive since it looks like you are dereferencing the
function pointer just like you would dereference any pointer.
Typically, however, people take advantage of the fact that the
compiler knows what is going on and will just use a shorter form:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pfi</span><span class="p">(</span><span class="mi">1234</span><span class="p">);</span>
</pre></div>
</div>
<p>This looks like you are calling a function named <code class="docutils literal notranslate"><span class="pre">pfi</span></code>, but the
compiler is smart enough to know to call through the variable <code class="docutils literal notranslate"><span class="pre">pfi</span></code>
indirectly to the function <code class="docutils literal notranslate"><span class="pre">MyFunction</span></code>.</p>
<p>Conceptually, this is almost exactly how the tracing system works.
Basically, a trace sink <em>is</em> a callback.  When a trace sink expresses
interest in receiving trace events, it adds itself as a Callback to a
list of Callbacks internally held by the trace source.  When an
interesting event happens, the trace source invokes its
<code class="docutils literal notranslate"><span class="pre">operator(...)</span></code> providing zero or more arguments.  The
<code class="docutils literal notranslate"><span class="pre">operator(...)</span></code> eventually wanders down into the system and does
something remarkably like the indirect call you just saw, providing
zero or more parameters, just as the call to <code class="docutils literal notranslate"><span class="pre">pfi</span></code> above passed one
parameter to the target function <code class="docutils literal notranslate"><span class="pre">MyFunction</span></code>.</p>
<p>The important difference that the tracing system adds is that for each
trace source there is an internal list of Callbacks.  Instead of just
making one indirect call, a trace source may invoke multiple
Callbacks.  When a trace sink expresses interest in notifications from
a trace source, it basically just arranges to add its own function to
the callback list.</p>
<p>If you are interested in more details about how this is actually
arranged in <em>ns-3</em>, feel free to peruse the Callback section of the
<em>ns-3</em> Manual.</p>
</section>
<section id="walkthrough-fourth-cc">
<h4><span class="section-number">8.2.1.2. </span>Walkthrough: <code class="docutils literal notranslate"><span class="pre">fourth.cc</span></code><a class="headerlink" href="#walkthrough-fourth-cc" title="Link to this heading">¶</a></h4>
<p>We have provided some code to implement what is really the simplest
example of tracing that can be assembled.  You can find this code in
the tutorial directory as <code class="docutils literal notranslate"><span class="pre">fourth.cc</span></code>.  Let’s walk through it:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ns3/object.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ns3/uinteger.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ns3/traced-value.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ns3/trace-source-accessor.h&quot;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ns3</span><span class="p">;</span>
</pre></div>
</div>
<p>Most of this code should be quite familiar to you.  As mentioned
above, the trace system makes heavy use of the Object and Attribute
systems, so you will need to include them.  The first two includes
above bring in the declarations for those systems explicitly.  You
could use the core module header to get everything at once, but we do
the includes explicitly here to illustrate how simple this all really
is.</p>
<p>The file, <code class="docutils literal notranslate"><span class="pre">traced-value.h</span></code> brings in the required declarations for
tracing of data that obeys value semantics.  In general, value
semantics just means that you can pass the object itself around,
rather than passing the address of the object.  What this all really
means is that you will be able to trace all changes made to a
TracedValue in a really simple way.</p>
<p>Since the tracing system is integrated with Attributes, and Attributes
work with Objects, there must be an <em>ns-3</em> <code class="docutils literal notranslate"><span class="pre">Object</span></code> for the trace
source to live in.  The next code snippet declares and defines a
simple Object we can work with.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyObject</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Object</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">TypeId</span><span class="w"> </span><span class="n">GetTypeId</span><span class="p">()</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">TypeId</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeId</span><span class="p">(</span><span class="s">&quot;MyObject&quot;</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="n">SetParent</span><span class="p">(</span><span class="n">Object</span><span class="o">::</span><span class="n">GetTypeId</span><span class="p">())</span>
<span class="w">      </span><span class="p">.</span><span class="n">SetGroupName</span><span class="p">(</span><span class="s">&quot;MyGroup&quot;</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="n">AddConstructor</span><span class="o">&lt;</span><span class="n">MyObject</span><span class="o">&gt;</span><span class="p">()</span>
<span class="w">      </span><span class="p">.</span><span class="n">AddTraceSource</span><span class="p">(</span><span class="s">&quot;MyInteger&quot;</span><span class="p">,</span>
<span class="w">                      </span><span class="s">&quot;An integer value to trace.&quot;</span><span class="p">,</span>
<span class="w">                      </span><span class="n">MakeTraceSourceAccessor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MyObject</span><span class="o">::</span><span class="n">m_myInt</span><span class="p">),</span>
<span class="w">                      </span><span class="s">&quot;ns3::TracedValueCallback::Int32&quot;</span><span class="p">)</span>
<span class="w">      </span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">tid</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">MyObject</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="w">  </span><span class="n">TracedValue</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_myInt</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The two important lines of code, above, with respect to tracing are
the <code class="docutils literal notranslate"><span class="pre">.AddTraceSource</span></code> and the <code class="docutils literal notranslate"><span class="pre">TracedValue</span></code> declaration of
<code class="docutils literal notranslate"><span class="pre">m_myInt</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">.AddTraceSource</span></code> provides the “hooks” used for connecting the
trace source to the outside world through the Config system.  The
first argument is a name for this trace source, which makes it
visible in the Config system. The second argument is a help string.
Now look at the third argument, in fact focus on the <em>argument</em> of
the third argument: <code class="docutils literal notranslate"><span class="pre">&amp;MyObject::m_myInt</span></code>. This is the TracedValue
which is being added to the class; it is always a class data member.
(The final argument is the name of a <code class="docutils literal notranslate"><span class="pre">typedef</span></code> for the TracedValue
type, as a string.  This is used to generate documentation for the
correct Callback function signature, which is useful especially
for more general types of Callbacks.)</p>
<p>The <code class="docutils literal notranslate"><span class="pre">TracedValue&lt;&gt;</span></code> declaration provides the infrastructure that
drives the callback process.  Any time the underlying value is changed
the TracedValue mechanism will provide both the old and the new value
of that variable, in this case an <code class="docutils literal notranslate"><span class="pre">int32_t</span></code> value.  The trace
sink function <code class="docutils literal notranslate"><span class="pre">traceSink</span></code> for this TracedValue will need the signature</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">traceSink</span><span class="p">)(</span><span class="kt">int32_t</span><span class="w"> </span><span class="n">oldValue</span><span class="p">,</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">newValue</span><span class="p">);</span>
</pre></div>
</div>
<p>All trace sinks hooking this trace source must have this signature.
We’ll discuss below how you can determine the required callback
signature in other cases.</p>
<p>Sure enough, continuing through <code class="docutils literal notranslate"><span class="pre">fourth.cc</span></code> we see:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">IntTrace</span><span class="p">(</span><span class="kt">int32_t</span><span class="w"> </span><span class="n">oldValue</span><span class="p">,</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">newValue</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Traced &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">oldValue</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; to &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">newValue</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is the definition of a matching trace sink.  It corresponds
directly to the callback function signature.  Once it is connected,
this function will be called whenever the <code class="docutils literal notranslate"><span class="pre">TracedValue</span></code> changes.</p>
<p>We have now seen the trace source and the trace sink.  What remains is
code to connect the source to the sink, which happens in <code class="docutils literal notranslate"><span class="pre">main</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">MyObject</span><span class="o">&gt;</span><span class="w"> </span><span class="n">myObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">MyObject</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="n">myObject</span><span class="o">-&gt;</span><span class="n">TraceConnectWithoutContext</span><span class="p">(</span><span class="s">&quot;MyInteger&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">MakeCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">IntTrace</span><span class="p">));</span>

<span class="w">  </span><span class="n">myObject</span><span class="o">-&gt;</span><span class="n">m_myInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1234</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here we first create the MyObject instance in which the trace source
lives.</p>
<p>The next step, the <code class="docutils literal notranslate"><span class="pre">TraceConnectWithoutContext</span></code>, forms the
connection between the trace source and the trace sink.  The first
argument is just the trace source name “MyInteger” we saw above.
Notice the <code class="docutils literal notranslate"><span class="pre">MakeCallback</span></code> template function.  This function does the
magic required to create the underlying <em>ns-3</em> Callback object and
associate it with the function <code class="docutils literal notranslate"><span class="pre">IntTrace</span></code>.  <code class="docutils literal notranslate"><span class="pre">TraceConnect</span></code> makes
the association between your provided function and overloaded
<code class="docutils literal notranslate"><span class="pre">operator()</span></code> in the traced variable referred to by the “MyInteger”
Attribute.  After this association is made, the trace source will
“fire” your provided callback function.</p>
<p>The code to make all of this happen is, of course, non-trivial, but
the essence is that you are arranging for something that looks just
like the <code class="docutils literal notranslate"><span class="pre">pfi()</span></code> example above to be called by the trace source.
The declaration of the <code class="docutils literal notranslate"><span class="pre">TracedValue&lt;int32_t&gt;</span> <span class="pre">m_myInt;</span></code> in the Object
itself performs the magic needed to provide the overloaded assignment
operators that will use the <code class="docutils literal notranslate"><span class="pre">operator()</span></code> to actually invoke the
Callback with the desired parameters.  The <code class="docutils literal notranslate"><span class="pre">.AddTraceSource</span></code>
performs the magic to connect the Callback to the Config system, and
<code class="docutils literal notranslate"><span class="pre">TraceConnectWithoutContext</span></code> performs the magic to connect your
function to the trace source, which is specified by Attribute name.</p>
<p>Let’s ignore the bit about context for now.</p>
<p>Finally, the line assigning a value to <code class="docutils literal notranslate"><span class="pre">m_myInt</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">myObject</span><span class="o">-&gt;</span><span class="n">m_myInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1234</span><span class="p">;</span>
</pre></div>
</div>
<p>should be interpreted as an invocation of <code class="docutils literal notranslate"><span class="pre">operator=</span></code> on the member
variable <code class="docutils literal notranslate"><span class="pre">m_myInt</span></code> with the integer <code class="docutils literal notranslate"><span class="pre">1234</span></code> passed as a parameter.</p>
<p>Since <code class="docutils literal notranslate"><span class="pre">m_myInt</span></code> is a <code class="docutils literal notranslate"><span class="pre">TracedValue</span></code>, this operator is defined to
execute a callback that returns void and takes two integer values as
parameters — an old value and a new value for the integer in
question.  That is exactly the function signature for the callback
function we provided — <code class="docutils literal notranslate"><span class="pre">IntTrace</span></code>.</p>
<p>To summarize, a trace source is, in essence, a variable that holds a
list of callbacks.  A trace sink is a function used as the target of a
callback.  The Attribute and object type information systems are used
to provide a way to connect trace sources to trace sinks.  The act of
“hitting” a trace source is executing an operator on the trace source
which fires callbacks.  This results in the trace sink callbacks who
registering interest in the source being called with the parameters
provided by the source.</p>
<p>If you now build and run this example,</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span>fourth
</pre></div>
</div>
<p>you will see the output from the <code class="docutils literal notranslate"><span class="pre">IntTrace</span></code> function execute as soon
as the trace source is hit:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Traced<span class="w"> </span><span class="m">0</span><span class="w"> </span>to<span class="w"> </span><span class="m">1234</span>
</pre></div>
</div>
<p>When we executed the code, <code class="docutils literal notranslate"><span class="pre">myObject-&gt;m_myInt</span> <span class="pre">=</span> <span class="pre">1234;</span></code>, the trace
source fired and automatically provided the before and after values to
the trace sink.  The function <code class="docutils literal notranslate"><span class="pre">IntTrace</span></code> then printed this to the
standard output.</p>
</section>
</section>
<section id="connect-with-config">
<span id="config"></span><h3><span class="section-number">8.2.2. </span>Connect with Config<a class="headerlink" href="#connect-with-config" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">TraceConnectWithoutContext</span></code> call shown above in the simple
example is actually very rarely used in the system.  More typically,
the <code class="docutils literal notranslate"><span class="pre">Config</span></code> subsystem is used to select a trace source in the
system using what is called a <em>Config path</em>.  We saw an example of
this in the previous section where we hooked the “CourseChange” event
when we were experimenting with <code class="docutils literal notranslate"><span class="pre">third.cc</span></code>.</p>
<p>Recall that we defined a trace sink to print course change information
from the mobility models of our simulation.  It should now be a lot
more clear to you what this function is doing:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">CourseChange</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">MobilityModel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">model</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Vector</span><span class="w"> </span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">model</span><span class="o">-&gt;</span><span class="n">GetPosition</span><span class="p">();</span>
<span class="w">  </span><span class="n">NS_LOG_UNCOND</span><span class="p">(</span><span class="n">context</span><span class="w"> </span><span class="o">&lt;&lt;</span>
<span class="w">    </span><span class="s">&quot; x = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, y = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When we connected the “CourseChange” trace source to the above trace
sink, we used a Config path to specify the source when we arranged a
connection between the pre-defined trace source and the new trace
sink:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span><span class="w"> </span><span class="n">oss</span><span class="p">;</span>
<span class="n">oss</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;/NodeList/&quot;</span>
<span class="w">    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">wifiStaNodes</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="n">nWifi</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetId</span><span class="p">()</span>
<span class="w">    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;/$ns3::MobilityModel/CourseChange&quot;</span><span class="p">;</span>

<span class="n">Config</span><span class="o">::</span><span class="n">Connect</span><span class="p">(</span><span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">(),</span><span class="w"> </span><span class="n">MakeCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CourseChange</span><span class="p">));</span>
</pre></div>
</div>
<p>Let’s try and make some sense of what is sometimes considered
relatively mysterious code.  For the purposes of discussion, assume
that the Node number returned by the <code class="docutils literal notranslate"><span class="pre">GetId()</span></code> is “7”.  In this
case, the path above turns out to be</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;/NodeList/7/$ns3::MobilityModel/CourseChange&quot;</span>
</pre></div>
</div>
<p>The last segment of a config path must be an <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> of an
<code class="docutils literal notranslate"><span class="pre">Object</span></code>.  In fact, if you had a pointer to the <code class="docutils literal notranslate"><span class="pre">Object</span></code> that has
the “CourseChange” <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> handy, you could write this just like
we did in the previous example.  You know by now that we typically
store pointers to our <code class="docutils literal notranslate"><span class="pre">Nodes</span></code> in a NodeContainer.  In the <code class="docutils literal notranslate"><span class="pre">third.cc</span></code>
example, the Nodes of interest are stored in the <code class="docutils literal notranslate"><span class="pre">wifiStaNodes</span></code>
NodeContainer.  In fact, while putting the path together, we used this
container to get a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Node&gt;</span></code> which we used to call <code class="docutils literal notranslate"><span class="pre">GetId()</span></code>.  We
could have used this <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Node&gt;</span></code> to call a Connect method
directly:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="w"> </span><span class="n">theObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wifiStaNodes</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="n">nWifi</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="n">theObject</span><span class="o">-&gt;</span><span class="n">TraceConnectWithoutContext</span><span class="p">(</span><span class="s">&quot;CourseChange&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">MakeCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CourseChange</span><span class="p">));</span>
</pre></div>
</div>
<p>In the <code class="docutils literal notranslate"><span class="pre">third.cc</span></code> example, we actually wanted an additional “context”
to be delivered along with the Callback parameters (which will be
explained below) so we could actually use the following equivalent
code:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="w"> </span><span class="n">theObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wifiStaNodes</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="n">nWifi</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="n">theObject</span><span class="o">-&gt;</span><span class="n">TraceConnect</span><span class="p">(</span><span class="s">&quot;CourseChange&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">MakeCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CourseChange</span><span class="p">));</span>
</pre></div>
</div>
<p>It turns out that the internal code for
<code class="docutils literal notranslate"><span class="pre">Config::ConnectWithoutContext</span></code> and <code class="docutils literal notranslate"><span class="pre">Config::Connect</span></code> actually
find a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Object&gt;</span></code> and call the appropriate <code class="docutils literal notranslate"><span class="pre">TraceConnect</span></code>
method at the lowest level.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Config</span></code> functions take a path that represents a chain of
<code class="docutils literal notranslate"><span class="pre">Object</span></code> pointers.  Each segment of a path corresponds to an Object
Attribute.  The last segment is the Attribute of interest, and prior
segments must be typed to contain or find Objects.  The <code class="docutils literal notranslate"><span class="pre">Config</span></code>
code parses and “walks” this path until it gets to the final segment
of the path.  It then interprets the last segment as an <code class="docutils literal notranslate"><span class="pre">Attribute</span></code>
on the last Object it found while walking the path.  The <code class="docutils literal notranslate"><span class="pre">Config</span></code>
functions then call the appropriate <code class="docutils literal notranslate"><span class="pre">TraceConnect</span></code> or
<code class="docutils literal notranslate"><span class="pre">TraceConnectWithoutContext</span></code> method on the final Object.  Let’s see
what happens in a bit more detail when the above path is walked.</p>
<p>The leading “/” character in the path refers to a so-called namespace.
One of the predefined namespaces in the config system is “NodeList”
which is a list of all of the nodes in the simulation.  Items in the
list are referred to by indices into the list, so “/NodeList/7” refers
to the eighth Node in the list of nodes created during the simulation
(recall indices start at <cite>0’).  This reference is actually a
``Ptr&lt;Node&gt;`</cite> and so is a subclass of an <code class="docutils literal notranslate"><span class="pre">ns3::Object</span></code>.</p>
<p>As described in the Object Model section of the <em>ns-3</em> Manual, we make
widespread use of object aggregation.  This allows us to form an
association between different Objects without building a complicated
inheritance tree or pre-deciding what objects will be part of a
Node.  Each Object in an Aggregation can be reached from the other
Objects.</p>
<p>In our example the next path segment being walked begins with the “$”
character.  This indicates to the config system that the segment is
the name of an object type, so a <code class="docutils literal notranslate"><span class="pre">GetObject</span></code> call should be made
looking for that type.  It turns out that the <code class="docutils literal notranslate"><span class="pre">MobilityHelper</span></code> used
in <code class="docutils literal notranslate"><span class="pre">third.cc</span></code> arranges to Aggregate, or associate, a mobility model
to each of the wireless <code class="docutils literal notranslate"><span class="pre">Nodes</span></code>.  When you add the “$” you are
asking for another Object that has presumably been previously
aggregated.  You can think of this as switching pointers from the
original Ptr&lt;Node&gt; as specified by “/NodeList/7” to its associated
mobility model — which is of type <code class="docutils literal notranslate"><span class="pre">ns3::MobilityModel</span></code>.  If you
are familiar with <code class="docutils literal notranslate"><span class="pre">GetObject</span></code>, we have asked the system to do the
following:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">MobilityModel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mobilityModel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">MobilityModel</span><span class="o">&gt;</span><span class="p">()</span>
</pre></div>
</div>
<p>We are now at the last Object in the path, so we turn our attention to
the Attributes of that Object.  The <code class="docutils literal notranslate"><span class="pre">MobilityModel</span></code> class defines an
Attribute called “CourseChange”.  You can see this by looking at the
source code in <code class="docutils literal notranslate"><span class="pre">src/mobility/model/mobility-model.cc</span></code> and searching
for “CourseChange” in your favorite editor.  You should find</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">AddTraceSource</span><span class="p">(</span><span class="s">&quot;CourseChange&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="s">&quot;The value of the position and/or velocity vector changed&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="n">MakeTraceSourceAccessor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MobilityModel</span><span class="o">::</span><span class="n">m_courseChangeTrace</span><span class="p">),</span>
<span class="w">                </span><span class="s">&quot;ns3::MobilityModel::CourseChangeCallback&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>which should look very familiar at this point.</p>
<p>If you look for the corresponding declaration of the underlying traced
variable in <code class="docutils literal notranslate"><span class="pre">mobility-model.h</span></code> you will find</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TracedCallback</span><span class="o">&lt;</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">MobilityModel</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">m_courseChangeTrace</span><span class="p">;</span>
</pre></div>
</div>
<p>The type declaration <code class="docutils literal notranslate"><span class="pre">TracedCallback</span></code> identifies
<code class="docutils literal notranslate"><span class="pre">m_courseChangeTrace</span></code> as a special list of Callbacks that can be
hooked using the Config functions described above.  The <code class="docutils literal notranslate"><span class="pre">typedef</span></code>
for the callback function signature is also defined in the header file:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="w"> </span><span class="n">CourseChangeCallback</span><span class="p">)(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">MobilityModel</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">model</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">MobilityModel</span></code> class is designed to be a base class providing a
common interface for all of the specific subclasses.  If you search
down to the end of the file, you will see a method defined called
<code class="docutils literal notranslate"><span class="pre">NotifyCourseChange()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">MobilityModel::NotifyCourseChange</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">m_courseChangeTrace</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Derived classes will call into this method whenever they do a course
change to support tracing.  This method invokes <code class="docutils literal notranslate"><span class="pre">operator()</span></code> on the
underlying <code class="docutils literal notranslate"><span class="pre">m_courseChangeTrace</span></code>, which will, in turn, invoke all of
the registered Callbacks, calling all of the trace sinks that have
registered interest in the trace source by calling a Config function.</p>
<p>So, in the <code class="docutils literal notranslate"><span class="pre">third.cc</span></code> example we looked at, whenever a course change
is made in one of the <code class="docutils literal notranslate"><span class="pre">RandomWalk2dMobilityModel</span></code> instances
installed, there will be a <code class="docutils literal notranslate"><span class="pre">NotifyCourseChange()</span></code> call which calls
up into the <code class="docutils literal notranslate"><span class="pre">MobilityModel</span></code> base class.  As seen above, this invokes
<code class="docutils literal notranslate"><span class="pre">operator()</span></code> on <code class="docutils literal notranslate"><span class="pre">m_courseChangeTrace</span></code>, which in turn, calls any
registered trace sinks.  In the example, the only code registering an
interest was the code that provided the Config path.  Therefore, the
<code class="docutils literal notranslate"><span class="pre">CourseChange</span></code> function that was hooked from Node number seven will
be the only Callback called.</p>
<p>The final piece of the puzzle is the “context”.  Recall that we saw an
output looking something like the following from <code class="docutils literal notranslate"><span class="pre">third.cc</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>/NodeList/7/$ns3::MobilityModel/CourseChange x = 7.27897, y =
2.22677
</pre></div>
</div>
<p>The first part of the output is the context.  It is simply the path
through which the config code located the trace source.  In the case
we have been looking at there can be any number of trace sources in
the system corresponding to any number of nodes with mobility models.
There needs to be some way to identify which trace source is actually
the one that fired the Callback.  The easy way is to connect with
<code class="docutils literal notranslate"><span class="pre">Config::Connect</span></code>, instead of <code class="docutils literal notranslate"><span class="pre">Config::ConnectWithoutContext</span></code>.</p>
</section>
<section id="finding-sources">
<h3><span class="section-number">8.2.3. </span>Finding Sources<a class="headerlink" href="#finding-sources" title="Link to this heading">¶</a></h3>
<p>The first question that inevitably comes up for new users of the
Tracing system is, <em>“Okay, I know that there must be trace sources in
the simulation core, but how do I find out what trace sources are
available to me?”</em></p>
<p>The second question is, <em>“Okay, I found a trace source, how do I figure
out the Config path to use when I connect to it?”</em></p>
<p>The third question is, <em>“Okay, I found a trace source and the Config
path, how do I figure out what the return type and formal arguments of
my callback function need to be?”</em></p>
<p>The fourth question is, <em>“Okay, I typed that all in and got this
incredibly bizarre error message, what in the world does it mean?”</em></p>
<p>We’ll address each of these in turn.</p>
</section>
<section id="available-sources">
<h3><span class="section-number">8.2.4. </span>Available Sources<a class="headerlink" href="#available-sources" title="Link to this heading">¶</a></h3>
<p><em>Okay, I know that there must be trace sources in the simulation core,
but how do I find out what trace sources are available to me?</em></p>
<p>The answer to the first question is found in the <em>ns-3</em> API
documentation.  If you go to the project web site, <a class="reference external" href="http://www.nsnam.org">ns-3 project</a>, you will find a link to “Documentation” in
the navigation bar.  If you select this link, you will be taken to our
documentation page. There is a link to “Latest Release” that will take
you to the documentation for the latest stable release of <em>ns-3</em>.  If
you select the “API Documentation” link, you will be taken to the
<em>ns-3</em> API documentation page.</p>
<p>In the sidebar you should see a hierarchy that begins</p>
<ul class="simple">
<li><p>ns-3</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>ns-3 Documentation</p></li>
<li><p>All TraceSources</p></li>
<li><p>All Attributes</p></li>
<li><p>All GlobalValues</p></li>
</ul>
</div></blockquote>
<p>The list of interest to us here is “All TraceSources”.  Go ahead and
select that link.  You will see, perhaps not too surprisingly, a list
of all of the trace sources available in <em>ns-3</em>.</p>
<p>As an example, scroll down to <code class="docutils literal notranslate"><span class="pre">ns3::MobilityModel</span></code>.  You will find
an entry for</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="nl">CourseChange</span><span class="p">:</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">position</span><span class="w"> </span><span class="n">and</span><span class="o">/</span><span class="n">or</span><span class="w"> </span><span class="n">velocity</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">changed</span>
</pre></div>
</div>
<p>You should recognize this as the trace source we used in the
<code class="docutils literal notranslate"><span class="pre">third.cc</span></code> example.  Perusing this list will be helpful.</p>
</section>
<section id="config-paths">
<h3><span class="section-number">8.2.5. </span>Config Paths<a class="headerlink" href="#config-paths" title="Link to this heading">¶</a></h3>
<p><em>Okay, I found a trace source, how do I figure out the Config path to
use when I connect to it?</em></p>
<p>If you know which object you are interested in, the “Detailed
Description” section for the class will list all available trace
sources.  For example, starting from the list of “All TraceSources,”
click on the <code class="docutils literal notranslate"><span class="pre">ns3::MobilityModel</span></code> link, which will take you to the
documentation for the <code class="docutils literal notranslate"><span class="pre">MobilityModel</span></code> class.  Almost at the top of
the page is a one line brief description of the class, ending in a
link “More…”.  Click on this link to skip the API summary and go to
the “Detailed Description” of the class.  At the end of the
description will be (up to) three lists:</p>
<ul class="simple">
<li><p><strong>Config Paths</strong>: a list of typical Config paths for this class.</p></li>
<li><p><strong>Attributes</strong>: a list of all attributes supplied by this class.</p></li>
<li><p><strong>TraceSources</strong>: a list of all TraceSources available from this class.</p></li>
</ul>
<p>First we’ll discuss the Config paths.</p>
<p>Let’s assume that you have just found the “CourseChange” trace source
in the “All TraceSources” list and you want to figure out how to
connect to it.  You know that you are using (again, from the
<code class="docutils literal notranslate"><span class="pre">third.cc</span></code> example) an <code class="docutils literal notranslate"><span class="pre">ns3::RandomWalk2dMobilityModel</span></code>.  So
either click on the class name in the “All TraceSources” list, or find
<code class="docutils literal notranslate"><span class="pre">ns3::RandomWalk2dMobilityModel</span></code> in the “Class List”.  Either way
you should now be looking at the “ns3::RandomWalk2dMobilityModel Class
Reference” page.</p>
<p>If you now scroll down to the “Detailed Description” section, after
the summary list of class methods and attributes (or just click on the
“More…” link at the end of the class brief description at the top of
the page) you will see the overall documentation for the class.
Continuing to scroll down, find the “Config Paths” list:</p>
<blockquote>
<div><p><strong>Config Paths</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">ns3::RandomWalk2dMobilityModel</span></code> is accessible through the
following paths with <code class="docutils literal notranslate"><span class="pre">Config::Set</span></code> and <code class="docutils literal notranslate"><span class="pre">Config::Connect</span></code>:</p>
<ul class="simple">
<li><p>“/NodeList/[i]/$ns3::MobilityModel/$ns3::RandomWalk2dMobilityModel”</p></li>
</ul>
</div></blockquote>
<p>The documentation tells you how to get to the
<code class="docutils literal notranslate"><span class="pre">RandomWalk2dMobilityModel</span></code> Object.  Compare the string above with
the string we actually used in the example code:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;/NodeList/7/$ns3::MobilityModel&quot;</span>
</pre></div>
</div>
<p>The difference is due to the fact that two <code class="docutils literal notranslate"><span class="pre">GetObject</span></code> calls are
implied in the string found in the documentation.  The first, for
<code class="docutils literal notranslate"><span class="pre">$ns3::MobilityModel</span></code> will query the aggregation for the base class.
The second implied <code class="docutils literal notranslate"><span class="pre">GetObject</span></code> call, for
<code class="docutils literal notranslate"><span class="pre">$ns3::RandomWalk2dMobilityModel</span></code>, is used to cast the base class to
the concrete implementation class.  The documentation shows both of
these operations for you.  It turns out that the actual trace source
you are looking for is found in the base class.</p>
<p>Look further down in the “Detailed Description” section for the list
of trace sources.  You will find</p>
<blockquote>
<div><p>No TraceSources are defined for this type.</p>
<p><strong>TraceSources defined in parent class ``ns3::MobilityModel``</strong></p>
<ul>
<li><p><strong>CourseChange</strong>: The value of the position and/or velocity vector
changed.</p>
<p>Callback signature: <code class="docutils literal notranslate"><span class="pre">ns3::MobilityModel::CourseChangeCallback</span></code></p>
</li>
</ul>
</div></blockquote>
<p>This is exactly what you need to know.  The trace source of interest
is found in <code class="docutils literal notranslate"><span class="pre">ns3::MobilityModel</span></code> (which you knew anyway).  The
interesting thing this bit of API Documentation tells you is that you
don’t need that extra cast in the config path above to get to the
concrete class, since the trace source is actually in the base class.
Therefore the additional <code class="docutils literal notranslate"><span class="pre">GetObject</span></code> is not required and you simply
use the path:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;/NodeList/[i]/$ns3::MobilityModel&quot;</span>
</pre></div>
</div>
<p>which perfectly matches the example path:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;/NodeList/7/$ns3::MobilityModel&quot;</span>
</pre></div>
</div>
<p>As an aside, another way to find the Config path is to <code class="docutils literal notranslate"><span class="pre">grep</span></code> around in
the <em>ns-3</em> codebase for someone who has already figured it out.  You
should always try to copy someone else’s working code before you start
to write your own.  Try something like:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>find<span class="w"> </span>.<span class="w"> </span>-name<span class="w"> </span><span class="s1">&#39;*.cc&#39;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>xargs<span class="w"> </span>grep<span class="w"> </span>CourseChange<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>Connect
</pre></div>
</div>
<p>and you may find your answer along with working code.  For example, in
this case, <code class="docutils literal notranslate"><span class="pre">src/mobility/examples/main-random-topology.cc</span></code> has
something just waiting for you to use:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">Connect</span><span class="p">(</span><span class="s">&quot;/NodeList/*/$ns3::MobilityModel/CourseChange&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="n">MakeCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CourseChange</span><span class="p">));</span>
</pre></div>
</div>
<p>We’ll return to this example in a moment.</p>
</section>
<section id="callback-signatures">
<h3><span class="section-number">8.2.6. </span>Callback Signatures<a class="headerlink" href="#callback-signatures" title="Link to this heading">¶</a></h3>
<p><em>Okay, I found a trace source and the Config path, how do I figure out
what the return type and formal arguments of my callback function need
to be?</em></p>
<p>The easiest way is to examine the callback signature <code class="docutils literal notranslate"><span class="pre">typedef</span></code>,
which is given in the “Callback signature” of the trace source in the
“Detailed Description” for the class, as shown above.</p>
<p>Repeating the “CourseChange” trace source entry from
<code class="docutils literal notranslate"><span class="pre">ns3::RandomWalk2dMobilityModel</span></code> we have:</p>
<blockquote>
<div><ul>
<li><p><strong>CourseChange</strong>: The value of the position and/or velocity vector
changed.</p>
<p>Callback signature: <code class="docutils literal notranslate"><span class="pre">ns3::MobilityModel::CourseChangeCallback</span></code></p>
</li>
</ul>
</div></blockquote>
<p>The callback signature is given as a link to the relevant <code class="docutils literal notranslate"><span class="pre">typedef</span></code>,
where we find</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">void</span> <span class="pre">(*</span> <span class="pre">CourseChangeCallback)(std::string</span> <span class="pre">context,</span> <span class="pre">Ptr&lt;const</span> <span class="pre">MobilityModel&gt;</span> <span class="pre">*</span> <span class="pre">model);</span></code></p>
<p><strong>TracedCallback</strong> signature for course change notifications.</p>
<p>If the callback is connected using <code class="docutils literal notranslate"><span class="pre">ConnectWithoutContext</span></code> omit the
<code class="docutils literal notranslate"><span class="pre">context</span></code> argument from the signature.</p>
<p><strong>Parameters</strong>:</p>
<blockquote>
<div><div class="line-block">
<div class="line">[in] <span class="param">context</span> The context string supplied by the Trace source.</div>
<div class="line">[in] <span class="param">model</span> The MobilityModel which is changing course.</div>
</div>
</div></blockquote>
</div></blockquote>
<p>As above, to see this in use <code class="docutils literal notranslate"><span class="pre">grep</span></code> around in the <em>ns-3</em> codebase for
an example.  The example above, from
<code class="docutils literal notranslate"><span class="pre">src/mobility/examples/main-random-topology.cc</span></code>, connects the
“CourseChange” trace source to the <code class="docutils literal notranslate"><span class="pre">CourseChange</span></code> function in the
same file:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">CourseChange</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">MobilityModel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">model</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Notice that this function:</p>
<ul class="simple">
<li><p>Takes a “context” string argument, which we’ll describe in a minute.
(If the callback is connected using the <code class="docutils literal notranslate"><span class="pre">ConnectWithoutContext</span></code>
function the <code class="docutils literal notranslate"><span class="pre">context</span></code> argument will be omitted.)</p></li>
<li><p>Has the <code class="docutils literal notranslate"><span class="pre">MobilityModel</span></code> supplied as the last argument (or only
argument if <code class="docutils literal notranslate"><span class="pre">ConnectWithoutContext</span></code> is used).</p></li>
<li><p>Returns <code class="docutils literal notranslate"><span class="pre">void</span></code>.</p></li>
</ul>
<p>If, by chance, the callback signature hasn’t been documented, and
there are no examples to work from, determining the right callback
function signature can be, well, challenging to actually figure out
from the source code.</p>
<p>Before embarking on a walkthrough of the code, I’ll be kind and just
tell you a simple way to figure this out: The return value of your
callback will always be <code class="docutils literal notranslate"><span class="pre">void</span></code>.  The formal parameter list for a
<code class="docutils literal notranslate"><span class="pre">TracedCallback</span></code> can be found from the template parameter list in
the declaration.  Recall that for our current example, this is in
<code class="docutils literal notranslate"><span class="pre">mobility-model.h</span></code>, where we have previously found:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TracedCallback</span><span class="o">&lt;</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">MobilityModel</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">m_courseChangeTrace</span><span class="p">;</span>
</pre></div>
</div>
<p>There is a one-to-one correspondence between the template parameter
list in the declaration and the formal arguments of the callback
function.  Here, there is one template parameter, which is a
<code class="docutils literal notranslate"><span class="pre">Ptr&lt;const</span> <span class="pre">MobilityModel&gt;</span></code>.  This tells you that you need a function
that returns void and takes a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;const</span> <span class="pre">MobilityModel&gt;</span></code>.  For
example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">CourseChange</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">MobilityModel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">model</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>That’s all you need if you want to <code class="docutils literal notranslate"><span class="pre">Config::ConnectWithoutContext</span></code>.
If you want a context, you need to <code class="docutils literal notranslate"><span class="pre">Config::Connect</span></code> and use a
Callback function that takes a string context, then the template
arguments:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">CourseChange</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">MobilityModel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">model</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you want to ensure that your <code class="docutils literal notranslate"><span class="pre">CourseChangeCallback</span></code> function is only
visible in your local file, you can add the keyword <code class="docutils literal notranslate"><span class="pre">static</span></code> and
come up with:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">CourseChange</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">MobilityModel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">model</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>which is exactly what we used in the <code class="docutils literal notranslate"><span class="pre">third.cc</span></code> example.</p>
<section id="implementation">
<h4><span class="section-number">8.2.6.1. </span>Implementation<a class="headerlink" href="#implementation" title="Link to this heading">¶</a></h4>
<p>This section is entirely optional.  It is going to be a bumpy ride,
especially for those unfamiliar with the details of templates.
However, if you get through this, you will have a very good handle on
a lot of the <em>ns-3</em> low level idioms.</p>
<p>So, again, let’s figure out what signature of callback function is
required for the “CourseChange” trace source.  This is going to be
painful, but you only need to do this once.  After you get through
this, you will be able to just look at a <code class="docutils literal notranslate"><span class="pre">TracedCallback</span></code> and
understand it.</p>
<p>The first thing we need to look at is the declaration of the trace
source.  Recall that this is in <code class="docutils literal notranslate"><span class="pre">mobility-model.h</span></code>, where we have
previously found:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TracedCallback</span><span class="o">&lt;</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">MobilityModel</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">m_courseChangeTrace</span><span class="p">;</span>
</pre></div>
</div>
<p>This declaration is for a template.  The template parameter is inside
the angle-brackets, so we are really interested in finding out what
that <code class="docutils literal notranslate"><span class="pre">TracedCallback&lt;&gt;</span></code> is.  If you have absolutely no idea where
this might be found, <code class="docutils literal notranslate"><span class="pre">grep</span></code> is your friend.</p>
<p>We are probably going to be interested in some kind of declaration in
the <em>ns-3</em> source, so first change into the <code class="docutils literal notranslate"><span class="pre">src</span></code> directory.  Then,
we know this declaration is going to have to be in some kind of header
file, so just <code class="docutils literal notranslate"><span class="pre">grep</span></code> for it using:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>find<span class="w"> </span>.<span class="w"> </span>-name<span class="w"> </span><span class="s1">&#39;*.h&#39;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>xargs<span class="w"> </span>grep<span class="w"> </span>TracedCallback
</pre></div>
</div>
<p>You’ll see 303 lines fly by (I piped this through <code class="docutils literal notranslate"><span class="pre">wc</span></code> to see how bad it
was).  Although that may seem like a lot, that’s not really a lot.  Just
pipe the output through <code class="docutils literal notranslate"><span class="pre">more</span></code> and start scanning through it.  On the
first page, you will see some very suspiciously template-looking
stuff.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TracedCallback</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="n">T2</span><span class="p">,</span><span class="n">T3</span><span class="p">,</span><span class="n">T4</span><span class="p">,</span><span class="n">T5</span><span class="p">,</span><span class="n">T6</span><span class="p">,</span><span class="n">T7</span><span class="p">,</span><span class="n">T8</span><span class="o">&gt;::</span><span class="n">TracedCallback</span><span class="p">()</span>
<span class="n">TracedCallback</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="n">T2</span><span class="p">,</span><span class="n">T3</span><span class="p">,</span><span class="n">T4</span><span class="p">,</span><span class="n">T5</span><span class="p">,</span><span class="n">T6</span><span class="p">,</span><span class="n">T7</span><span class="p">,</span><span class="n">T8</span><span class="o">&gt;::</span><span class="n">ConnectWithoutContext</span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="p">...</span>
<span class="n">TracedCallback</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="n">T2</span><span class="p">,</span><span class="n">T3</span><span class="p">,</span><span class="n">T4</span><span class="p">,</span><span class="n">T5</span><span class="p">,</span><span class="n">T6</span><span class="p">,</span><span class="n">T7</span><span class="p">,</span><span class="n">T8</span><span class="o">&gt;::</span><span class="n">Connect</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">CallbackB</span><span class="w"> </span><span class="p">...</span>
<span class="n">TracedCallback</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="n">T2</span><span class="p">,</span><span class="n">T3</span><span class="p">,</span><span class="n">T4</span><span class="p">,</span><span class="n">T5</span><span class="p">,</span><span class="n">T6</span><span class="p">,</span><span class="n">T7</span><span class="p">,</span><span class="n">T8</span><span class="o">&gt;::</span><span class="n">DisconnectWithoutContext</span><span class="w"> </span><span class="p">...</span>
<span class="n">TracedCallback</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="n">T2</span><span class="p">,</span><span class="n">T3</span><span class="p">,</span><span class="n">T4</span><span class="p">,</span><span class="n">T5</span><span class="p">,</span><span class="n">T6</span><span class="p">,</span><span class="n">T7</span><span class="p">,</span><span class="n">T8</span><span class="o">&gt;::</span><span class="n">Disconnect</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Callba</span><span class="w"> </span><span class="p">...</span>
<span class="n">TracedCallback</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="n">T2</span><span class="p">,</span><span class="n">T3</span><span class="p">,</span><span class="n">T4</span><span class="p">,</span><span class="n">T5</span><span class="p">,</span><span class="n">T6</span><span class="p">,</span><span class="n">T7</span><span class="p">,</span><span class="n">T8</span><span class="o">&gt;::</span><span class="k">operator</span><span class="p">()()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">...</span>
<span class="n">TracedCallback</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="n">T2</span><span class="p">,</span><span class="n">T3</span><span class="p">,</span><span class="n">T4</span><span class="p">,</span><span class="n">T5</span><span class="p">,</span><span class="n">T6</span><span class="p">,</span><span class="n">T7</span><span class="p">,</span><span class="n">T8</span><span class="o">&gt;::</span><span class="k">operator</span><span class="p">()(</span><span class="n">T1</span><span class="w"> </span><span class="n">a1</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">...</span>
<span class="n">TracedCallback</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="n">T2</span><span class="p">,</span><span class="n">T3</span><span class="p">,</span><span class="n">T4</span><span class="p">,</span><span class="n">T5</span><span class="p">,</span><span class="n">T6</span><span class="p">,</span><span class="n">T7</span><span class="p">,</span><span class="n">T8</span><span class="o">&gt;::</span><span class="k">operator</span><span class="p">()(</span><span class="n">T1</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">a2</span><span class="w"> </span><span class="p">...</span>
<span class="n">TracedCallback</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="n">T2</span><span class="p">,</span><span class="n">T3</span><span class="p">,</span><span class="n">T4</span><span class="p">,</span><span class="n">T5</span><span class="p">,</span><span class="n">T6</span><span class="p">,</span><span class="n">T7</span><span class="p">,</span><span class="n">T8</span><span class="o">&gt;::</span><span class="k">operator</span><span class="p">()(</span><span class="n">T1</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">a2</span><span class="w"> </span><span class="p">...</span>
<span class="n">TracedCallback</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="n">T2</span><span class="p">,</span><span class="n">T3</span><span class="p">,</span><span class="n">T4</span><span class="p">,</span><span class="n">T5</span><span class="p">,</span><span class="n">T6</span><span class="p">,</span><span class="n">T7</span><span class="p">,</span><span class="n">T8</span><span class="o">&gt;::</span><span class="k">operator</span><span class="p">()(</span><span class="n">T1</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">a2</span><span class="w"> </span><span class="p">...</span>
<span class="n">TracedCallback</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="n">T2</span><span class="p">,</span><span class="n">T3</span><span class="p">,</span><span class="n">T4</span><span class="p">,</span><span class="n">T5</span><span class="p">,</span><span class="n">T6</span><span class="p">,</span><span class="n">T7</span><span class="p">,</span><span class="n">T8</span><span class="o">&gt;::</span><span class="k">operator</span><span class="p">()(</span><span class="n">T1</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">a2</span><span class="w"> </span><span class="p">...</span>
<span class="n">TracedCallback</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="n">T2</span><span class="p">,</span><span class="n">T3</span><span class="p">,</span><span class="n">T4</span><span class="p">,</span><span class="n">T5</span><span class="p">,</span><span class="n">T6</span><span class="p">,</span><span class="n">T7</span><span class="p">,</span><span class="n">T8</span><span class="o">&gt;::</span><span class="k">operator</span><span class="p">()(</span><span class="n">T1</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">a2</span><span class="w"> </span><span class="p">...</span>
<span class="n">TracedCallback</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="n">T2</span><span class="p">,</span><span class="n">T3</span><span class="p">,</span><span class="n">T4</span><span class="p">,</span><span class="n">T5</span><span class="p">,</span><span class="n">T6</span><span class="p">,</span><span class="n">T7</span><span class="p">,</span><span class="n">T8</span><span class="o">&gt;::</span><span class="k">operator</span><span class="p">()(</span><span class="n">T1</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">a2</span><span class="w"> </span><span class="p">...</span>
</pre></div>
</div>
<p>It turns out that all of this comes from the header file
<code class="docutils literal notranslate"><span class="pre">traced-callback.h</span></code> which sounds very promising.  You can then take
a look at <code class="docutils literal notranslate"><span class="pre">mobility-model.h</span></code> and see that there is a line which
confirms this hunch:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ns3/traced-callback.h&quot;</span>
</pre></div>
</div>
<p>Of course, you could have gone at this from the other direction and
started by looking at the includes in <code class="docutils literal notranslate"><span class="pre">mobility-model.h</span></code> and
noticing the include of <code class="docutils literal notranslate"><span class="pre">traced-callback.h</span></code> and inferring that this
must be the file you want.</p>
<p>In either case, the next step is to take a look at
<code class="docutils literal notranslate"><span class="pre">src/core/model/traced-callback.h</span></code> in your favorite editor to see
what is happening.</p>
<p>You will see a comment at the top of the file that should be
comforting:</p>
<blockquote>
<div><p>An ns3::TracedCallback has almost exactly the same API as a normal
ns3::Callback but instead of forwarding calls to a single function
(as an ns3::Callback normally does), it forwards calls to a chain of
ns3::Callback.</p>
</div></blockquote>
<p>This should sound very familiar and let you know you are on the right
track.</p>
<p>Just after this comment, you will find</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">empty</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">empty</span><span class="p">,</span>
<span class="w">         </span><span class="k">typename</span><span class="w"> </span><span class="nc">T3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">empty</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">empty</span><span class="p">,</span>
<span class="w">         </span><span class="k">typename</span><span class="w"> </span><span class="nc">T5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">empty</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">empty</span><span class="p">,</span>
<span class="w">         </span><span class="k">typename</span><span class="w"> </span><span class="nc">T7</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">empty</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">empty</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TracedCallback</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
</pre></div>
</div>
<p>This tells you that TracedCallback is a templated class.  It has eight
possible type parameters with default values.  Go back and compare
this with the declaration you are trying to understand:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TracedCallback</span><span class="o">&lt;</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">MobilityModel</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">m_courseChangeTrace</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">typename</span> <span class="pre">T1</span></code> in the templated class declaration corresponds to
the <code class="docutils literal notranslate"><span class="pre">Ptr&lt;const</span> <span class="pre">MobilityModel&gt;</span></code> in the declaration above.  All of the
other type parameters are left as defaults.  Looking at the
constructor really doesn’t tell you much.  The one place where you
have seen a connection made between your Callback function and the
tracing system is in the <code class="docutils literal notranslate"><span class="pre">Connect</span></code> and <code class="docutils literal notranslate"><span class="pre">ConnectWithoutContext</span></code>
functions.  If you scroll down, you will see a
<code class="docutils literal notranslate"><span class="pre">ConnectWithoutContext</span></code> method here:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="p">,</span>
<span class="w">         </span><span class="k">typename</span><span class="w"> </span><span class="nc">T3</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T4</span><span class="p">,</span>
<span class="w">         </span><span class="k">typename</span><span class="w"> </span><span class="nc">T5</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T6</span><span class="p">,</span>
<span class="w">         </span><span class="k">typename</span><span class="w"> </span><span class="nc">T7</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T8</span><span class="o">&gt;</span>
<span class="kt">void</span>
<span class="n">TracedCallback</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="n">T2</span><span class="p">,</span><span class="n">T3</span><span class="p">,</span><span class="n">T4</span><span class="p">,</span><span class="n">T5</span><span class="p">,</span><span class="n">T6</span><span class="p">,</span><span class="n">T7</span><span class="p">,</span><span class="n">T8</span><span class="o">&gt;::</span><span class="n">ConnectWithoutContext</span><span class="w"> </span><span class="p">...</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Callback</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">,</span><span class="n">T1</span><span class="p">,</span><span class="n">T2</span><span class="p">,</span><span class="n">T3</span><span class="p">,</span><span class="n">T4</span><span class="p">,</span><span class="n">T5</span><span class="p">,</span><span class="n">T6</span><span class="p">,</span><span class="n">T7</span><span class="p">,</span><span class="n">T8</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cb</span><span class="p">;</span>
<span class="w">  </span><span class="n">cb</span><span class="p">.</span><span class="n">Assign</span><span class="p">(</span><span class="n">callback</span><span class="p">);</span>
<span class="w">  </span><span class="n">m_callbackList</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You are now in the belly of the beast.  When the template is
instantiated for the declaration above, the compiler will replace
<code class="docutils literal notranslate"><span class="pre">T1</span></code> with <code class="docutils literal notranslate"><span class="pre">Ptr&lt;const</span> <span class="pre">MobilityModel&gt;</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="n">TracedCallback</span><span class="o">&lt;</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">MobilityModel</span><span class="o">&gt;::</span><span class="n">ConnectWithoutContext</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">cb</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Callback</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">MobilityModel</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">cb</span><span class="p">;</span>
<span class="w">  </span><span class="n">cb</span><span class="p">.</span><span class="n">Assign</span><span class="p">(</span><span class="n">callback</span><span class="p">);</span>
<span class="w">  </span><span class="n">m_callbackList</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You can now see the implementation of everything we’ve been talking
about.  The code creates a Callback of the right type and assigns your
function to it.  This is the equivalent of the <code class="docutils literal notranslate"><span class="pre">pfi</span> <span class="pre">=</span> <span class="pre">MyFunction</span></code> we
discussed at the start of this section.  The code then adds the
Callback to the list of Callbacks for this source.  The only thing
left is to look at the definition of Callback.  Using the same <code class="docutils literal notranslate"><span class="pre">grep</span></code>
trick as we used to find <code class="docutils literal notranslate"><span class="pre">TracedCallback</span></code>, you will be able to find
that the file <code class="docutils literal notranslate"><span class="pre">./core/callback.h</span></code> is the one we need to look at.</p>
<p>If you look down through the file, you will see a lot of probably
almost incomprehensible template code.  You will eventually come to
some API Documentation for the Callback template class, though.  Fortunately,
there is some English:</p>
<blockquote>
<div><p><strong>Callback</strong> template class.</p>
<p>This class template implements the Functor Design Pattern. It is used to declare the type of a <strong>Callback</strong>:</p>
<ul class="simple">
<li><p>the first non-optional template argument represents the return type of the callback.</p></li>
<li><p>the remaining (optional) template arguments represent the type of the subsequent arguments to the callback.</p></li>
<li><p>up to nine arguments are supported.</p></li>
</ul>
</div></blockquote>
<p>We are trying to figure out what the</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Callback</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">MobilityModel</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">cb</span><span class="p">;</span>
</pre></div>
</div>
<p>declaration means.  Now we are in a position to understand that the
first (non-optional) template argument, <code class="docutils literal notranslate"><span class="pre">void</span></code>, represents the
return type of the Callback.  The second (optional) template argument,
<code class="docutils literal notranslate"><span class="pre">Ptr&lt;const</span> <span class="pre">MobilityModel&gt;</span></code> represents the type of the first argument
to the callback.</p>
<p>The Callback in question is your function to receive the trace events.
From this you can infer that you need a function that returns <code class="docutils literal notranslate"><span class="pre">void</span></code>
and takes a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;const</span> <span class="pre">MobilityModel&gt;</span></code>.  For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">CourseChangeCallback</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">MobilityModel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">model</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>That’s all you need if you want to <code class="docutils literal notranslate"><span class="pre">Config::ConnectWithoutContext</span></code>.
If you want a context, you need to <code class="docutils literal notranslate"><span class="pre">Config::Connect</span></code> and use a
Callback function that takes a string context.  This is because the
<code class="docutils literal notranslate"><span class="pre">Connect</span></code> function will provide the context for you.  You’ll need:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">CourseChangeCallback</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">MobilityModel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">model</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you want to ensure that your <code class="docutils literal notranslate"><span class="pre">CourseChangeCallback</span></code> is only
visible in your local file, you can add the keyword <code class="docutils literal notranslate"><span class="pre">static</span></code> and
come up with:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">CourseChangeCallback</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">MobilityModel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">model</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>which is exactly what we used in the <code class="docutils literal notranslate"><span class="pre">third.cc</span></code> example.  Perhaps
you should now go back and reread the previous section (Take My Word
for It).</p>
<p>If you are interested in more details regarding the implementation of
Callbacks, feel free to take a look at the <em>ns-3</em> manual.  They are one
of the most frequently used constructs in the low-level parts of
<em>ns-3</em>.  It is, in my opinion, a quite elegant thing.</p>
</section>
</section>
<section id="tracedvalues">
<h3><span class="section-number">8.2.7. </span>TracedValues<a class="headerlink" href="#tracedvalues" title="Link to this heading">¶</a></h3>
<p>Earlier in this section, we presented a simple piece of code that used
a <code class="docutils literal notranslate"><span class="pre">TracedValue&lt;int32_t&gt;</span></code> to demonstrate the basics of the tracing
code.  We just glossed over the what a TracedValue really is and how
to find the return type and formal arguments for the callback.</p>
<p>As we mentioned, the file, <code class="docutils literal notranslate"><span class="pre">traced-value.h</span></code> brings in the required
declarations for tracing of data that obeys value semantics.  In
general, value semantics just means that you can pass the object
itself around, rather than passing the address of the object.  We
extend that requirement to include the full set of assignment-style
operators that are pre-defined for plain-old-data (POD) types:</p>
<blockquote>
<div><table class="docutils align-default">
<tbody>
<tr class="row-odd"><td colspan="2"><p><code class="docutils literal notranslate"><span class="pre">operator=</span></code> (assignment)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">operator*=</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">operator/=</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">operator+=</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">operator-=</span></code></p></td>
</tr>
<tr class="row-even"><td colspan="2"><p><code class="docutils literal notranslate"><span class="pre">operator++</span></code> (both prefix and postfix)</p></td>
</tr>
<tr class="row-odd"><td colspan="2"><p><code class="docutils literal notranslate"><span class="pre">operator--</span></code> (both prefix and postfix)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">operator&lt;&lt;=</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">operator&gt;&gt;=</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">operator&amp;=</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">operator|=</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">operator%=</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">operator^=</span></code></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>What this all really means is that you will be able to trace all
changes made using those operators to a C++ object which has value
semantics.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">TracedValue&lt;&gt;</span></code> declaration we saw above provides the
infrastructure that overloads the operators mentioned above and drives
the callback process.  On use of any of the operators above with a
<code class="docutils literal notranslate"><span class="pre">TracedValue</span></code> it will provide both the old and the new value of that
variable, in this case an <code class="docutils literal notranslate"><span class="pre">int32_t</span></code> value.  By inspection of the
<code class="docutils literal notranslate"><span class="pre">TracedValue</span></code> declaration, we know the trace sink function will have
arguments <code class="docutils literal notranslate"><span class="pre">(int32_t</span> <span class="pre">oldValue,</span> <span class="pre">int32_t</span> <span class="pre">newValue)</span></code>.  The
return type for a <code class="docutils literal notranslate"><span class="pre">TracedValue</span></code> callback function is always
<code class="docutils literal notranslate"><span class="pre">void</span></code>, so the expected callback signature for the sink function
<code class="docutils literal notranslate"><span class="pre">traceSink</span></code> will be:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="w"> </span><span class="n">traceSink</span><span class="p">)(</span><span class="kt">int32_t</span><span class="w"> </span><span class="n">oldValue</span><span class="p">,</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">newValue</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">.AddTraceSource</span></code> in the <code class="docutils literal notranslate"><span class="pre">GetTypeId</span></code> method provides the
“hooks” used for connecting the trace source to the outside world
through the Config system.  We already discussed the first three
arguments to <code class="docutils literal notranslate"><span class="pre">AddTraceSource</span></code>: the Attribute name for the Config
system, a help string, and the address of the TracedValue class data
member.</p>
<p>The final string argument, “ns3::TracedValueCallback::Int32” in the example,
is the name of a <code class="docutils literal notranslate"><span class="pre">typedef</span></code> for the callback function signature.  We
require these signatures to be defined, and give the fully qualified
type name to <code class="docutils literal notranslate"><span class="pre">AddTraceSource</span></code>, so the API documentation can link a
trace source to the function signature.  For TracedValue the signature
is straightforward; for TracedCallbacks we’ve already seen the API
docs really help.</p>
</section>
</section>
<section id="real-example">
<h2><span class="section-number">8.3. </span>Real Example<a class="headerlink" href="#real-example" title="Link to this heading">¶</a></h2>
<p>Let’s do an example taken from one of the best-known books on TCP
around.  “TCP/IP Illustrated, Volume 1: The Protocols,” by W. Richard
Stevens is a classic.  I just flipped the book open and ran across a
nice plot of both the congestion window and sequence numbers versus
time on page 366.  Stevens calls this, “Figure 21.10. Value of cwnd
and send sequence number while data is being transmitted.”  Let’s just
recreate the cwnd part of that plot in <em>ns-3</em> using the tracing system
and <code class="docutils literal notranslate"><span class="pre">gnuplot</span></code>.</p>
<section id="id1">
<h3><span class="section-number">8.3.1. </span>Available Sources<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h3>
<p>The first thing to think about is how we want to get the data out.
What is it that we need to trace?  So let’s consult “All Trace
Sources” list to see what we have to work with.  Recall that this is
found in the <em>ns-3</em> API Documentation.  If you scroll through the list,
you will eventually find:</p>
<blockquote>
<div><p><strong>ns3::TcpSocketBase</strong></p>
<ul class="simple">
<li><p><strong>CongestionWindow</strong>: The TCP connection’s congestion window</p></li>
<li><p><strong>SlowStartThreshold</strong>: TCP slow start threshold (bytes)</p></li>
</ul>
</div></blockquote>
<p>It turns out that the <em>ns-3</em> TCP implementation lives (mostly) in the
file <code class="docutils literal notranslate"><span class="pre">src/internet/model/tcp-socket-base.cc</span></code> while congestion
control variants are in files such as
<code class="docutils literal notranslate"><span class="pre">src/internet/model/tcp-bic.cc</span></code>.  If you don’t know this <em>a
priori</em>, you can use the recursive <code class="docutils literal notranslate"><span class="pre">grep</span></code> trick:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>find<span class="w"> </span>.<span class="w"> </span>-name<span class="w"> </span><span class="s1">&#39;*.cc&#39;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>xargs<span class="w"> </span>grep<span class="w"> </span>-i<span class="w"> </span>tcp
</pre></div>
</div>
<p>You will find page after page of instances of tcp pointing you to that
file.</p>
<p>Bringing up the class documentation for <code class="docutils literal notranslate"><span class="pre">TcpSocketBase</span></code> and skipping to
the list of TraceSources you will find</p>
<blockquote>
<div><p><strong>TraceSources</strong></p>
<ul>
<li><p><strong>CongestionWindow</strong>: The TCP connection’s congestion window</p>
<p>Callback signature:  <strong>ns3::TracedValueCallback::Uint32</strong></p>
</li>
</ul>
</div></blockquote>
<p>Clicking on the callback <code class="docutils literal notranslate"><span class="pre">typedef</span></code> link we see the signature
you now know to expect:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="w"> </span><span class="n">ns3</span><span class="o">::</span><span class="n">TracedValueCallback</span><span class="o">::</span><span class="n">Int32</span><span class="p">)(</span><span class="kt">int32_t</span><span class="w"> </span><span class="n">oldValue</span><span class="p">,</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">newValue</span><span class="p">)</span>
</pre></div>
</div>
<p>You should now understand this code completely.  If we have a pointer
to the <code class="docutils literal notranslate"><span class="pre">TcpSocketBase</span></code> object, we can <code class="docutils literal notranslate"><span class="pre">TraceConnect</span></code> to the
“CongestionWindow” trace source if we provide an appropriate callback
target.  This is the same kind of trace source that we saw in the
simple example at the start of this section, except that we are
talking about <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> instead of <code class="docutils literal notranslate"><span class="pre">int32_t</span></code>.  And we know
that we have to provide a callback function with that signature.</p>
</section>
<section id="finding-examples">
<h3><span class="section-number">8.3.2. </span>Finding Examples<a class="headerlink" href="#finding-examples" title="Link to this heading">¶</a></h3>
<p>It’s always best to try and find working code laying around that you
can modify, rather than starting from scratch.  So the first order of
business now is to find some code that already hooks the
“CongestionWindow” trace source and see if we can modify it.  As
usual, <code class="docutils literal notranslate"><span class="pre">grep</span></code> is your friend:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>find<span class="w"> </span>.<span class="w"> </span>-name<span class="w"> </span><span class="s1">&#39;*.cc&#39;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>xargs<span class="w"> </span>grep<span class="w"> </span>CongestionWindow
</pre></div>
</div>
<p>This will point out a couple of promising candidates:
<code class="docutils literal notranslate"><span class="pre">examples/tcp/tcp-large-transfer.cc</span></code> and
<code class="docutils literal notranslate"><span class="pre">src/test/ns3tcp/ns3tcp-cwnd-test-suite.cc</span></code>.</p>
<p>We haven’t visited any of the test code yet, so let’s take a look
there.  You will typically find that test code is fairly minimal, so
this is probably a very good bet.  Open
<code class="docutils literal notranslate"><span class="pre">src/test/ns3tcp/ns3tcp-cwnd-test-suite.cc</span></code> in your favorite editor
and search for “CongestionWindow”.  You will find,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ns3TcpSocket</span><span class="o">-&gt;</span><span class="n">TraceConnectWithoutContext</span><span class="p">(</span><span class="s">&quot;CongestionWindow&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="n">MakeCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Ns3TcpCwndTestCase1</span><span class="o">::</span><span class="n">CwndChange</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">));</span>
</pre></div>
</div>
<p>This should look very familiar to you.  We mentioned above that if we
had a pointer to the <code class="docutils literal notranslate"><span class="pre">TcpSocketBase</span></code>, we could <code class="docutils literal notranslate"><span class="pre">TraceConnect</span></code> to the
“CongestionWindow” trace source.  That’s exactly what we have here; so
it turns out that this line of code does exactly what we want.  Let’s
go ahead and extract the code we need from this function
(<code class="docutils literal notranslate"><span class="pre">Ns3TcpCwndTestCase1::DoRun()</span></code>).  If you look at this
function, you will find that it looks just like an <em>ns-3</em> script.  It
turns out that is exactly what it is.  It is a script run by the test
framework, so we can just pull it out and wrap it in <code class="docutils literal notranslate"><span class="pre">main</span></code> instead
of in <code class="docutils literal notranslate"><span class="pre">DoRun</span></code>.  Rather than walk through this, step, by step, we
have provided the file that results from porting this test back to a
native <em>ns-3</em> script – <code class="docutils literal notranslate"><span class="pre">examples/tutorial/fifth.cc</span></code>.</p>
</section>
<section id="dynamic-trace-sources">
<h3><span class="section-number">8.3.3. </span>Dynamic Trace Sources<a class="headerlink" href="#dynamic-trace-sources" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">fifth.cc</span></code> example demonstrates an extremely important rule that
you must understand before using any kind of trace source: you must
ensure that the target of a <code class="docutils literal notranslate"><span class="pre">Config::Connect</span></code> command exists before
trying to use it.  This is no different than saying an object must be
instantiated before trying to call it.  Although this may seem obvious
when stated this way, it does trip up many people trying to use the
system for the first time.</p>
<p>Let’s return to basics for a moment.  There are three basic execution
phases that exist in any <em>ns-3</em> script.  The first phase is
sometimes called “Configuration Time” or “Setup Time,” and exists
during the period when the <code class="docutils literal notranslate"><span class="pre">main</span></code> function of your script is
running, but before <code class="docutils literal notranslate"><span class="pre">Simulator::Run</span></code> is called.  The second phase
is sometimes called “Simulation Time” and exists during
the time period when <code class="docutils literal notranslate"><span class="pre">Simulator::Run</span></code> is actively executing its
events.  After it completes executing the simulation,
<code class="docutils literal notranslate"><span class="pre">Simulator::Run</span></code> will return control back to the <code class="docutils literal notranslate"><span class="pre">main</span></code> function.
When this happens, the script enters what can be called the “Teardown
Phase,” which is when the structures and objects created during setup
are taken apart and released.</p>
<p>Perhaps the most common mistake made in trying to use the tracing
system is assuming that entities constructed dynamically <em>during
simulation time</em> are available during configuration time.  In
particular, an <em>ns-3</em> <code class="docutils literal notranslate"><span class="pre">Socket</span></code> is a dynamic object often created by
<code class="docutils literal notranslate"><span class="pre">Applications</span></code> to communicate between <code class="docutils literal notranslate"><span class="pre">Nodes</span></code>.  An <em>ns-3</em>
<code class="docutils literal notranslate"><span class="pre">Application</span></code> always has a “Start Time” and a “Stop Time” associated
with it.  In the vast majority of cases, an <code class="docutils literal notranslate"><span class="pre">Application</span></code> will not
attempt to create a dynamic object until its <code class="docutils literal notranslate"><span class="pre">StartApplication</span></code>
method is called at some “Start Time”.  This is to ensure that the
simulation is completely configured before the app tries to do
anything (what would happen if it tried to connect to a Node that
didn’t exist yet during configuration time?).  As a result, during the
configuration phase you can’t connect a trace source to a trace sink
if one of them is created dynamically during the simulation.</p>
<p>The two solutions to this conundrum are</p>
<ol class="arabic simple">
<li><p>Create a simulator event that is run after the dynamic object is
created and hook the trace when that event is executed; or</p></li>
<li><p>Create the dynamic object at configuration time, hook it then, and
give the object to the system to use during simulation time.</p></li>
</ol>
<p>We took the second approach in the <code class="docutils literal notranslate"><span class="pre">fifth.cc</span></code> example.  This
decision required us to create the <code class="docutils literal notranslate"><span class="pre">TutorialApp</span></code> <code class="docutils literal notranslate"><span class="pre">Application</span></code>, the
entire purpose of which is to take a <code class="docutils literal notranslate"><span class="pre">Socket</span></code> as a parameter.</p>
</section>
<section id="walkthrough-fifth-cc">
<h3><span class="section-number">8.3.4. </span>Walkthrough: <code class="docutils literal notranslate"><span class="pre">fifth.cc</span></code><a class="headerlink" href="#walkthrough-fifth-cc" title="Link to this heading">¶</a></h3>
<p>Now, let’s take a look at the example program we constructed by
dissecting the congestion window test.  Open
<code class="docutils literal notranslate"><span class="pre">examples/tutorial/fifth.cc</span></code> in your favorite editor.  You should
see some familiar looking code:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Include., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;tutorial-app.h&quot;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ns3/applications-module.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ns3/core-module.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ns3/internet-module.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ns3/network-module.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ns3/point-to-point-module.h&quot;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;fstream&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ns3</span><span class="p">;</span>

<span class="n">NS_LOG_COMPONENT_DEFINE</span><span class="p">(</span><span class="s">&quot;FifthScriptExample&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The next lines of
source are the network illustration and a comment addressing the
problem described above with <code class="docutils literal notranslate"><span class="pre">Socket</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// ===========================================================================</span>
<span class="c1">//</span>
<span class="c1">//         node 0                 node 1</span>
<span class="c1">//   +----------------+    +----------------+</span>
<span class="c1">//   |    ns-3 TCP    |    |    ns-3 TCP    |</span>
<span class="c1">//   +----------------+    +----------------+</span>
<span class="c1">//   |    10.1.1.1    |    |    10.1.1.2    |</span>
<span class="c1">//   +----------------+    +----------------+</span>
<span class="c1">//   | point-to-point |    | point-to-point |</span>
<span class="c1">//   +----------------+    +----------------+</span>
<span class="c1">//           |                     |</span>
<span class="c1">//           +---------------------+</span>
<span class="c1">//                5 Mbps, 2 ms</span>
<span class="c1">//</span>
<span class="c1">//</span>
<span class="c1">// We want to look at changes in the ns-3 TCP congestion window.  We need</span>
<span class="c1">// to crank up a flow and hook the CongestionWindow attribute on the socket</span>
<span class="c1">// of the sender.  Normally one would use an on-off application to generate a</span>
<span class="c1">// flow, but this has a couple of problems.  First, the socket of the on-off</span>
<span class="c1">// application is not created until Application Start time, so we wouldn&#39;t be</span>
<span class="c1">// able to hook the socket (now) at configuration time.  Second, even if we</span>
<span class="c1">// could arrange a call after start time, the socket is not public so we</span>
<span class="c1">// couldn&#39;t get at it.</span>
<span class="c1">//</span>
<span class="c1">// So, we can cook up a simple version of the on-off application that does what</span>
<span class="c1">// we want.  On the plus side we don&#39;t need all of the complexity of the on-off</span>
<span class="c1">// application.  On the minus side, we don&#39;t have a helper, so we have to get</span>
<span class="c1">// a little more involved in the details, but this is trivial.</span>
<span class="c1">//</span>
<span class="c1">// So first, we create a socket and do the trace connect on it; then we pass</span>
<span class="c1">// this socket into the constructor of our simple application which we then</span>
<span class="c1">// install in the source node.</span>
<span class="c1">// ===========================================================================</span>
<span class="c1">//</span>
</pre></div>
</div>
<p>This should also be self-explanatory.</p>
<p>Previous versions of <em>ns-3</em> declared a custom application called <code class="docutils literal notranslate"><span class="pre">MyApp</span></code>
for use in this program.  Current versions of <em>ns-3</em> have moved this to
a separate header file (<code class="docutils literal notranslate"><span class="pre">tutorial-app.h</span></code>) and implementation file
(<code class="docutils literal notranslate"><span class="pre">tutorial-app.cc</span></code>).  This simple application allows the <code class="docutils literal notranslate"><span class="pre">Socket</span></code>
to be created at configuration time.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Tutorial - a simple Application sending packets.</span>
<span class="cm"> */</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TutorialApp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Application</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">TutorialApp</span><span class="p">();</span>
<span class="w">    </span><span class="o">~</span><span class="n">TutorialApp</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * Register this type.</span>
<span class="cm">     * \return The TypeId.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">TypeId</span><span class="w"> </span><span class="nf">GetTypeId</span><span class="p">();</span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * Setup the socket.</span>
<span class="cm">     * \param socket The socket.</span>
<span class="cm">     * \param address The destination address.</span>
<span class="cm">     * \param packetSize The packet size to transmit.</span>
<span class="cm">     * \param nPackets The number of packets to transmit.</span>
<span class="cm">     * \param dataRate the data rate to use.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Setup</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Socket</span><span class="o">&gt;</span><span class="w"> </span><span class="n">socket</span><span class="p">,</span>
<span class="w">               </span><span class="n">Address</span><span class="w"> </span><span class="n">address</span><span class="p">,</span>
<span class="w">               </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">packetSize</span><span class="p">,</span>
<span class="w">               </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">nPackets</span><span class="p">,</span>
<span class="w">               </span><span class="n">DataRate</span><span class="w"> </span><span class="n">dataRate</span><span class="p">);</span>

<span class="w">  </span><span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">StartApplication</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">StopApplication</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">    </span><span class="c1">/// Schedule a new transmission.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">ScheduleTx</span><span class="p">();</span>
<span class="w">    </span><span class="c1">/// Send a packet.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">SendPacket</span><span class="p">();</span>

<span class="w">    </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Socket</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_socket</span><span class="p">;</span><span class="w">   </span><span class="c1">//!&lt; The transmission socket.</span>
<span class="w">    </span><span class="n">Address</span><span class="w"> </span><span class="n">m_peer</span><span class="p">;</span><span class="w">         </span><span class="c1">//!&lt; The destination address.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">m_packetSize</span><span class="p">;</span><span class="w">  </span><span class="c1">//!&lt; The packet size.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">m_nPackets</span><span class="p">;</span><span class="w">    </span><span class="c1">//!&lt; The number of packets to send.</span>
<span class="w">    </span><span class="n">DataRate</span><span class="w"> </span><span class="n">m_dataRate</span><span class="p">;</span><span class="w">    </span><span class="c1">//!&lt; The data rate to use.</span>
<span class="w">    </span><span class="n">EventId</span><span class="w"> </span><span class="n">m_sendEvent</span><span class="p">;</span><span class="w">    </span><span class="c1">//!&lt; Send event.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">m_running</span><span class="p">;</span><span class="w">         </span><span class="c1">//!&lt; True if the application is running.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">m_packetsSent</span><span class="p">;</span><span class="w"> </span><span class="c1">//!&lt; The number of packets sent.</span>
<span class="p">};</span>
</pre></div>
</div>
<p>You can see that this class inherits from the <em>ns-3</em> <code class="docutils literal notranslate"><span class="pre">Application</span></code>
class.  Take a look at <code class="docutils literal notranslate"><span class="pre">src/network/model/application.h</span></code> if you are
interested in what is inherited.  The <code class="docutils literal notranslate"><span class="pre">TutorialApp</span></code> class is obligated to
override the <code class="docutils literal notranslate"><span class="pre">StartApplication</span></code> and <code class="docutils literal notranslate"><span class="pre">StopApplication</span></code> methods.
These methods are automatically called when <code class="docutils literal notranslate"><span class="pre">TutorialApp</span></code> is required to
start and stop sending data during the simulation.</p>
<section id="starting-stopping-applications">
<h4><span class="section-number">8.3.4.1. </span>Starting/Stopping Applications<a class="headerlink" href="#starting-stopping-applications" title="Link to this heading">¶</a></h4>
<p>It is worthwhile to spend a bit of time explaining how events actually
get started in the system.  This is another fairly deep explanation,
and can be ignored if you aren’t planning on venturing down into the
guts of the system.  It is useful, however, in that the discussion
touches on how some very important parts of <em>ns-3</em> work and exposes
some important idioms.  If you are planning on implementing new
models, you probably want to understand this section.</p>
<p>The most common way to start pumping events is to start an
<code class="docutils literal notranslate"><span class="pre">Application</span></code>.  This is done as the result of the following
(hopefully) familiar lines of an <em>ns-3</em> script:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ApplicationContainer</span><span class="w"> </span><span class="n">apps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span>
<span class="n">apps</span><span class="p">.</span><span class="n">Start</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>
<span class="n">apps</span><span class="p">.</span><span class="n">Stop</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">10.0</span><span class="p">));</span>
</pre></div>
</div>
<p>The application container code (see
<code class="docutils literal notranslate"><span class="pre">src/network/helper/application-container.h</span></code> if you are interested)
loops through its contained applications and calls,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">app</span><span class="o">-&gt;</span><span class="n">SetStartTime</span><span class="p">(</span><span class="n">startTime</span><span class="p">);</span>
</pre></div>
</div>
<p>as a result of the <code class="docutils literal notranslate"><span class="pre">apps.Start</span></code> call and</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">app</span><span class="o">-&gt;</span><span class="n">SetStopTime</span><span class="p">(</span><span class="n">stopTime</span><span class="p">);</span>
</pre></div>
</div>
<p>as a result of the <code class="docutils literal notranslate"><span class="pre">apps.Stop</span></code> call.</p>
<p>The ultimate result of these calls is that we want to have the
simulator automatically make calls into our <code class="docutils literal notranslate"><span class="pre">Applications</span></code> to tell
them when to start and stop.  In the case of <code class="docutils literal notranslate"><span class="pre">TutorialApp</span></code>, it inherits
from class <code class="docutils literal notranslate"><span class="pre">Application</span></code> and overrides <code class="docutils literal notranslate"><span class="pre">StartApplication</span></code>, and
<code class="docutils literal notranslate"><span class="pre">StopApplication</span></code>.  These are the functions that will be called by
the simulator at the appropriate time.  In the case of <code class="docutils literal notranslate"><span class="pre">TutorialApp</span></code> you
will find that <code class="docutils literal notranslate"><span class="pre">TutorialApp::StartApplication</span></code> does the initial <code class="docutils literal notranslate"><span class="pre">Bind</span></code>,
and <code class="docutils literal notranslate"><span class="pre">Connect</span></code> on the socket, and then starts data flowing by calling
<code class="docutils literal notranslate"><span class="pre">TutorialApp::SendPacket</span></code>.  <code class="docutils literal notranslate"><span class="pre">TutorialApp::StopApplication</span></code> stops generating
packets by cancelling any pending send events then closes the socket.</p>
<p>One of the nice things about <em>ns-3</em> is that you can completely ignore
the implementation details of how your <code class="docutils literal notranslate"><span class="pre">Application</span></code> is
“automagically” called by the simulator at the correct time.  But
since we have already ventured deep into <em>ns-3</em> already, let’s go for
it.</p>
<p>If you look at <code class="docutils literal notranslate"><span class="pre">src/network/model/application.cc</span></code> you will find that
the <code class="docutils literal notranslate"><span class="pre">SetStartTime</span></code> method of an <code class="docutils literal notranslate"><span class="pre">Application</span></code> just sets the member
variable <code class="docutils literal notranslate"><span class="pre">m_startTime</span></code> and the <code class="docutils literal notranslate"><span class="pre">SetStopTime</span></code> method just sets
<code class="docutils literal notranslate"><span class="pre">m_stopTime</span></code>.  From there, without some hints, the trail will
probably end.</p>
<p>The key to picking up the trail again is to know that there is a
global list of all of the nodes in the system.  Whenever you create a
node in a simulation, a pointer to that Node is added to the global
<code class="docutils literal notranslate"><span class="pre">NodeList</span></code>.</p>
<p>Take a look at <code class="docutils literal notranslate"><span class="pre">src/network/model/node-list.cc</span></code> and search for
<code class="docutils literal notranslate"><span class="pre">NodeList::Add</span></code>.  The public static implementation calls into a
private implementation called <code class="docutils literal notranslate"><span class="pre">NodeListPriv::Add</span></code>.  This is a
relatively common idiom in <em>ns-3</em>.  So, take a look at
<code class="docutils literal notranslate"><span class="pre">NodeListPriv::Add</span></code>.  There you will find,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Simulator</span><span class="o">::</span><span class="n">ScheduleWithContext</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">TimeStep</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Node</span><span class="o">::</span><span class="n">Initialize</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">);</span>
</pre></div>
</div>
<p>This tells you that whenever a Node is created in a simulation, as
a side-effect, a call to that node’s <code class="docutils literal notranslate"><span class="pre">Initialize</span></code> method is
scheduled for you that happens at time zero.  Don’t read too much into
that name, yet.  It doesn’t mean that the Node is going to start doing
anything, it can be interpreted as an informational call into the
Node telling it that the simulation has started, not a call for
action telling the Node to start doing something.</p>
<p>So, <code class="docutils literal notranslate"><span class="pre">NodeList::Add</span></code> indirectly schedules a call to
<code class="docutils literal notranslate"><span class="pre">Node::Initialize</span></code> at time zero to advise a new Node that the
simulation has started.  If you look in <code class="docutils literal notranslate"><span class="pre">src/network/model/node.h</span></code>
you will, however, not find a method called <code class="docutils literal notranslate"><span class="pre">Node::Initialize</span></code>.  It
turns out that the <code class="docutils literal notranslate"><span class="pre">Initialize</span></code> method is inherited from class
<code class="docutils literal notranslate"><span class="pre">Object</span></code>.  All objects in the system can be notified when the
simulation starts, and objects of class Node are just one kind of
those objects.</p>
<p>Take a look at <code class="docutils literal notranslate"><span class="pre">src/core/model/object.cc</span></code> next and search for
<code class="docutils literal notranslate"><span class="pre">Object::Initialize</span></code>.  This code is not as straightforward as you
might have expected since <em>ns-3</em> <code class="docutils literal notranslate"><span class="pre">Objects</span></code> support aggregation.  The
code in <code class="docutils literal notranslate"><span class="pre">Object::Initialize</span></code> then loops through all of the objects
that have been aggregated together and calls their <code class="docutils literal notranslate"><span class="pre">DoInitialize</span></code>
method.  This is another idiom that is very common in <em>ns-3</em>, sometimes
called the “template design pattern.”: a public non-virtual API
method, which stays constant across implementations, and that calls a
private virtual implementation method that is inherited and
implemented by subclasses.  The names are typically something like
<code class="docutils literal notranslate"><span class="pre">MethodName</span></code> for the public API and <code class="docutils literal notranslate"><span class="pre">DoMethodName</span></code> for the private
API.</p>
<p>This tells us that we should look for a <code class="docutils literal notranslate"><span class="pre">Node::DoInitialize</span></code> method
in <code class="docutils literal notranslate"><span class="pre">src/network/model/node.cc</span></code> for the method that will continue our
trail.  If you locate the code, you will find a method that loops
through all of the devices in the Node and then all of the
applications in the Node calling <code class="docutils literal notranslate"><span class="pre">device-&gt;Initialize</span></code> and
<code class="docutils literal notranslate"><span class="pre">application-&gt;Initialize</span></code> respectively.</p>
<p>You may already know that classes <code class="docutils literal notranslate"><span class="pre">Device</span></code> and <code class="docutils literal notranslate"><span class="pre">Application</span></code> both
inherit from class <code class="docutils literal notranslate"><span class="pre">Object</span></code> and so the next step will be to look at
what happens when <code class="docutils literal notranslate"><span class="pre">Application::DoInitialize</span></code> is called.  Take a
look at <code class="docutils literal notranslate"><span class="pre">src/network/model/application.cc</span></code> and you will find:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">Application::DoInitialize</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">NS_LOG_FUNCTION</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="w">  </span><span class="n">m_startEvent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Schedule</span><span class="p">(</span><span class="n">m_startTime</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Application</span><span class="o">::</span><span class="n">StartApplication</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_stopTime</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">TimeStep</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">m_stopEvent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Schedule</span><span class="p">(</span><span class="n">m_stopTime</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Application</span><span class="o">::</span><span class="n">StopApplication</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="n">Object</span><span class="o">::</span><span class="n">DoInitialize</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, we finally come to the end of the trail.  If you have kept it
all straight, when you implement an <em>ns-3</em> <code class="docutils literal notranslate"><span class="pre">Application</span></code>, your new
application inherits from class <code class="docutils literal notranslate"><span class="pre">Application</span></code>.  You override the
<code class="docutils literal notranslate"><span class="pre">StartApplication</span></code> and <code class="docutils literal notranslate"><span class="pre">StopApplication</span></code> methods and provide
mechanisms for starting and stopping the flow of data out of your new
<code class="docutils literal notranslate"><span class="pre">Application</span></code>.  When a Node is created in the simulation, it is
added to a global <code class="docutils literal notranslate"><span class="pre">NodeList</span></code>.  The act of adding a Node to this
<code class="docutils literal notranslate"><span class="pre">NodeList</span></code> causes a simulator event to be scheduled for time zero
which calls the <code class="docutils literal notranslate"><span class="pre">Node::Initialize</span></code> method of the newly added
Node to be called when the simulation starts.  Since a Node
inherits from <code class="docutils literal notranslate"><span class="pre">Object</span></code>, this calls the <code class="docutils literal notranslate"><span class="pre">Object::Initialize</span></code> method
on the Node which, in turn, calls the <code class="docutils literal notranslate"><span class="pre">DoInitialize</span></code> methods on
all of the <code class="docutils literal notranslate"><span class="pre">Objects</span></code> aggregated to the Node (think mobility
models).  Since the Node <code class="docutils literal notranslate"><span class="pre">Object</span></code> has overridden
<code class="docutils literal notranslate"><span class="pre">DoInitialize</span></code>, that method is called when the simulation starts.
The <code class="docutils literal notranslate"><span class="pre">Node::DoInitialize</span></code> method calls the <code class="docutils literal notranslate"><span class="pre">Initialize</span></code> methods of
all of the <code class="docutils literal notranslate"><span class="pre">Applications</span></code> on the node.  Since <code class="docutils literal notranslate"><span class="pre">Applications</span></code> are
also <code class="docutils literal notranslate"><span class="pre">Objects</span></code>, this causes <code class="docutils literal notranslate"><span class="pre">Application::DoInitialize</span></code> to be
called.  When <code class="docutils literal notranslate"><span class="pre">Application::DoInitialize</span></code> is called, it schedules
events for the <code class="docutils literal notranslate"><span class="pre">StartApplication</span></code> and <code class="docutils literal notranslate"><span class="pre">StopApplication</span></code> calls on
the <code class="docutils literal notranslate"><span class="pre">Application</span></code>.  These calls are designed to start and stop the
flow of data from the <code class="docutils literal notranslate"><span class="pre">Application</span></code></p>
<p>This has been another fairly long journey, but it only has to be made
once, and you now understand another very deep piece of <em>ns-3</em>.</p>
</section>
<section id="the-tutorialapp-application">
<h4><span class="section-number">8.3.4.2. </span>The TutorialApp Application<a class="headerlink" href="#the-tutorialapp-application" title="Link to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">TutorialApp</span></code> <code class="docutils literal notranslate"><span class="pre">Application</span></code> needs a constructor and a destructor, of
course:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TutorialApp</span><span class="o">::</span><span class="n">TutorialApp</span><span class="p">()</span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="n">m_socket</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span>
<span class="w">      </span><span class="n">m_peer</span><span class="p">(),</span>
<span class="w">      </span><span class="n">m_packetSize</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
<span class="w">      </span><span class="n">m_nPackets</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
<span class="w">      </span><span class="n">m_dataRate</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
<span class="w">      </span><span class="n">m_sendEvent</span><span class="p">(),</span>
<span class="w">      </span><span class="n">m_running</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
<span class="w">      </span><span class="n">m_packetsSent</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="n">TutorialApp</span><span class="o">::~</span><span class="n">TutorialApp</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">m_socket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The existence of the next bit of code is the whole reason why we wrote
this <code class="docutils literal notranslate"><span class="pre">Application</span></code> in the first place.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">TutorialApp::Setup</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Socket</span><span class="o">&gt;</span><span class="w"> </span><span class="n">socket</span><span class="p">,</span>
<span class="w">                   </span><span class="n">Address</span><span class="w"> </span><span class="n">address</span><span class="p">,</span>
<span class="w">                   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">packetSize</span><span class="p">,</span>
<span class="w">                   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">nPackets</span><span class="p">,</span>
<span class="w">                   </span><span class="n">DataRate</span><span class="w"> </span><span class="n">dataRate</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">m_socket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket</span><span class="p">;</span>
<span class="w">    </span><span class="n">m_peer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">;</span>
<span class="w">    </span><span class="n">m_packetSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">packetSize</span><span class="p">;</span>
<span class="w">    </span><span class="n">m_nPackets</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nPackets</span><span class="p">;</span>
<span class="w">    </span><span class="n">m_dataRate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dataRate</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This code should be pretty self-explanatory.  We are just initializing
member variables.  The important one from the perspective of tracing
is the <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Socket&gt;</span> <span class="pre">socket</span></code> which we needed to provide to the
application during configuration time.  Recall that we are going to
create the <code class="docutils literal notranslate"><span class="pre">Socket</span></code> as a <code class="docutils literal notranslate"><span class="pre">TcpSocket</span></code> (which is implemented by
<code class="docutils literal notranslate"><span class="pre">TcpSocketBase</span></code>) and hook its “CongestionWindow” trace source before
passing it to the <code class="docutils literal notranslate"><span class="pre">Setup</span></code> method.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">TutorialApp::StartApplication</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">m_running</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="n">m_packetsSent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">m_socket</span><span class="o">-&gt;</span><span class="n">Bind</span><span class="p">();</span>
<span class="w">    </span><span class="n">m_socket</span><span class="o">-&gt;</span><span class="n">Connect</span><span class="p">(</span><span class="n">m_peer</span><span class="p">);</span>
<span class="w">    </span><span class="n">SendPacket</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above code is the overridden implementation
<code class="docutils literal notranslate"><span class="pre">Application::StartApplication</span></code> that will be automatically called by
the simulator to start our <code class="docutils literal notranslate"><span class="pre">Application</span></code> running at the appropriate
time.  You can see that it does a <code class="docutils literal notranslate"><span class="pre">Socket</span></code> <code class="docutils literal notranslate"><span class="pre">Bind</span></code> operation.  If
you are familiar with Berkeley Sockets this shouldn’t be a surprise.
It performs the required work on the local side of the connection just
as you might expect.  The following <code class="docutils literal notranslate"><span class="pre">Connect</span></code> will do what is
required to establish a connection with the TCP at <code class="docutils literal notranslate"><span class="pre">Address</span></code> m_peer.
It should now be clear why we need to defer a lot of this to
simulation time, since the <code class="docutils literal notranslate"><span class="pre">Connect</span></code> is going to need a fully
functioning network to complete.  After the <code class="docutils literal notranslate"><span class="pre">Connect</span></code>, the
<code class="docutils literal notranslate"><span class="pre">Application</span></code> then starts creating simulation events by calling
<code class="docutils literal notranslate"><span class="pre">SendPacket</span></code>.</p>
<p>The next bit of code explains to the <code class="docutils literal notranslate"><span class="pre">Application</span></code> how to stop
creating simulation events.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">TutorialApp::StopApplication</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">m_running</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_sendEvent</span><span class="p">.</span><span class="n">IsRunning</span><span class="p">())</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Cancel</span><span class="p">(</span><span class="n">m_sendEvent</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_socket</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">m_socket</span><span class="o">-&gt;</span><span class="n">Close</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Every time a simulation event is scheduled, an <code class="docutils literal notranslate"><span class="pre">Event</span></code> is created.
If the <code class="docutils literal notranslate"><span class="pre">Event</span></code> is pending execution or executing, its method
<code class="docutils literal notranslate"><span class="pre">IsRunning</span></code> will return <code class="docutils literal notranslate"><span class="pre">true</span></code>.  In this code, if <code class="docutils literal notranslate"><span class="pre">IsRunning()</span></code>
returns true, we <code class="docutils literal notranslate"><span class="pre">Cancel</span></code> the event which removes it from the
simulator event queue.  By doing this, we break the chain of events
that the <code class="docutils literal notranslate"><span class="pre">Application</span></code> is using to keep sending its <code class="docutils literal notranslate"><span class="pre">Packets</span></code> and
the <code class="docutils literal notranslate"><span class="pre">Application</span></code> goes quiet.  After we quiet the <code class="docutils literal notranslate"><span class="pre">Application</span></code> we
<code class="docutils literal notranslate"><span class="pre">Close</span></code> the socket which tears down the TCP connection.</p>
<p>The socket is actually deleted in the destructor when the <code class="docutils literal notranslate"><span class="pre">m_socket</span> <span class="pre">=</span>
<span class="pre">0</span></code> is executed.  This removes the last reference to the underlying
Ptr&lt;Socket&gt; which causes the destructor of that Object to be called.</p>
<p>Recall that <code class="docutils literal notranslate"><span class="pre">StartApplication</span></code> called <code class="docutils literal notranslate"><span class="pre">SendPacket</span></code> to start the
chain of events that describes the <code class="docutils literal notranslate"><span class="pre">Application</span></code> behavior.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">TutorialApp::SendPacket</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">packet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Create</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_packetSize</span><span class="p">);</span>
<span class="w">    </span><span class="n">m_socket</span><span class="o">-&gt;</span><span class="n">Send</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">++</span><span class="n">m_packetsSent</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m_nPackets</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ScheduleTx</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, you see that <code class="docutils literal notranslate"><span class="pre">SendPacket</span></code> does just that.  It creates a
<code class="docutils literal notranslate"><span class="pre">Packet</span></code> and then does a <code class="docutils literal notranslate"><span class="pre">Send</span></code> which, if you know Berkeley
Sockets, is probably just what you expected to see.</p>
<p>It is the responsibility of the <code class="docutils literal notranslate"><span class="pre">Application</span></code> to keep scheduling the
chain of events, so the next lines call <code class="docutils literal notranslate"><span class="pre">ScheduleTx</span></code> to schedule
another transmit event (a <code class="docutils literal notranslate"><span class="pre">SendPacket</span></code>) until the <code class="docutils literal notranslate"><span class="pre">Application</span></code>
decides it has sent enough.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">TutorialApp::ScheduleTx</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_running</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">Time</span><span class="w"> </span><span class="n">tNext</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="n">m_packetSize</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_dataRate</span><span class="p">.</span><span class="n">GetBitRate</span><span class="p">())));</span>
<span class="w">        </span><span class="n">m_sendEvent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Schedule</span><span class="p">(</span><span class="n">tNext</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">TutorialApp</span><span class="o">::</span><span class="n">SendPacket</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, you see that <code class="docutils literal notranslate"><span class="pre">ScheduleTx</span></code> does exactly that.  If the
<code class="docutils literal notranslate"><span class="pre">Application</span></code> is running (if <code class="docutils literal notranslate"><span class="pre">StopApplication</span></code> has not been
called) it will schedule a new event, which calls <code class="docutils literal notranslate"><span class="pre">SendPacket</span></code>
again.  The alert reader will spot something that also trips up new
users.  The data rate of an <code class="docutils literal notranslate"><span class="pre">Application</span></code> is just that.  It has
nothing to do with the data rate of an underlying <code class="docutils literal notranslate"><span class="pre">Channel</span></code>.  This
is the rate at which the <code class="docutils literal notranslate"><span class="pre">Application</span></code> produces bits.  It does not
take into account any overhead for the various protocols or channels
that it uses to transport the data.  If you set the data rate of an
<code class="docutils literal notranslate"><span class="pre">Application</span></code> to the same data rate as your underlying <code class="docutils literal notranslate"><span class="pre">Channel</span></code>
you will eventually get a buffer overflow.</p>
</section>
<section id="trace-sinks">
<h4><span class="section-number">8.3.4.3. </span>Trace Sinks<a class="headerlink" href="#trace-sinks" title="Link to this heading">¶</a></h4>
<p>The whole point of this exercise is to get trace callbacks from TCP
indicating the congestion window has been updated.  The next piece of
code implements the corresponding trace sink:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">CwndChange</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">oldCwnd</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">newCwnd</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">NS_LOG_UNCOND</span><span class="p">(</span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">newCwnd</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This should be very familiar to you now, so we won’t dwell on the
details.  This function just logs the current simulation time and the
new value of the congestion window every time it is changed.  You can
probably imagine that you could load the resulting output into a
graphics program (gnuplot or Excel) and immediately see a nice graph
of the congestion window behavior over time.</p>
<p>We added a new trace sink to show where packets are dropped.  We are
going to add an error model to this code also, so we wanted to
demonstrate this working.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">RxDrop</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Packet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">NS_LOG_UNCOND</span><span class="p">(</span><span class="s">&quot;RxDrop at &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This trace sink will be connected to the “PhyRxDrop” trace source of
the point-to-point NetDevice.  This trace source fires when a packet
is dropped by the physical layer of a <code class="docutils literal notranslate"><span class="pre">NetDevice</span></code>.  If you take a
small detour to the source
(<code class="docutils literal notranslate"><span class="pre">src/point-to-point/model/point-to-point-net-device.cc</span></code>) you will
see that this trace source refers to
<code class="docutils literal notranslate"><span class="pre">PointToPointNetDevice::m_phyRxDropTrace</span></code>.  If you then look in
<code class="docutils literal notranslate"><span class="pre">src/point-to-point/model/point-to-point-net-device.h</span></code> for this
member variable, you will find that it is declared as a
<code class="docutils literal notranslate"><span class="pre">TracedCallback&lt;Ptr&lt;const</span> <span class="pre">Packet&gt;&gt;</span></code>.  This should tell you that the
callback target should be a function that returns void and takes a
single parameter which is a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;const</span> <span class="pre">Packet&gt;</span></code> (assuming we use
<code class="docutils literal notranslate"><span class="pre">ConnectWithoutContext</span></code>) – just what we have above.</p>
</section>
<section id="main-program">
<h4><span class="section-number">8.3.4.4. </span>Main Program<a class="headerlink" href="#main-program" title="Link to this heading">¶</a></h4>
<p>The main function starts off by configuring the TCP type to use a legacy
<code class="docutils literal notranslate"><span class="pre">NewReno</span></code> congestion control variant, with what is called the <code class="docutils literal notranslate"><span class="pre">classic</span></code>
TCP loss recovery mechanism.  When this tutorial program was originally
written, these were the default TCP configurations, but over time,
<em>ns-3</em> TCP has evolved to use the current Linux TCP defaults of <code class="docutils literal notranslate"><span class="pre">Cubic</span></code>
and <code class="docutils literal notranslate"><span class="pre">Prr</span></code> loss recovery.  The first statements also configure the
command-line argument processing.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">CommandLine</span><span class="w"> </span><span class="n">cmd</span><span class="p">(</span><span class="n">__FILE__</span><span class="p">);</span>
<span class="w">    </span><span class="n">cmd</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// In the following three lines, TCP NewReno is used as the congestion</span>
<span class="w">    </span><span class="c1">// control algorithm, the initial congestion window of a TCP connection is</span>
<span class="w">    </span><span class="c1">// set to 1 packet, and the classic fast recovery algorithm is used. Note</span>
<span class="w">    </span><span class="c1">// that this configuration is used only to demonstrate how TCP parameters</span>
<span class="w">    </span><span class="c1">// can be configured in ns-3. Otherwise, it is recommended to use the default</span>
<span class="w">    </span><span class="c1">// settings of TCP in ns-3.</span>
<span class="w">    </span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::TcpL4Protocol::SocketType&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;ns3::TcpNewReno&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::TcpSocket::InitialCwnd&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="w">    </span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::TcpL4Protocol::RecoveryType&quot;</span><span class="p">,</span>
<span class="w">                       </span><span class="n">TypeIdValue</span><span class="p">(</span><span class="n">TypeId</span><span class="o">::</span><span class="n">LookupByName</span><span class="p">(</span><span class="s">&quot;ns3::TcpClassicRecovery&quot;</span><span class="p">)));</span>
</pre></div>
</div>
<p>The following code should be very familiar to you by now:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">nodes</span><span class="p">;</span>
<span class="n">nodes</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="n">PointToPointHelper</span><span class="w"> </span><span class="n">pointToPoint</span><span class="p">;</span>
<span class="n">pointToPoint</span><span class="p">.</span><span class="n">SetDeviceAttribute</span><span class="p">(</span><span class="s">&quot;DataRate&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;5Mbps&quot;</span><span class="p">));</span>
<span class="n">pointToPoint</span><span class="p">.</span><span class="n">SetChannelAttribute</span><span class="p">(</span><span class="s">&quot;Delay&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;2ms&quot;</span><span class="p">));</span>

<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">devices</span><span class="p">;</span>
<span class="n">devices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pointToPoint</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">nodes</span><span class="p">);</span>
</pre></div>
</div>
<p>This creates two nodes with a point-to-point channel between them,
just as shown in the illustration at the start of the file.</p>
<p>The next few lines of code show something new.  If we trace a
connection that behaves perfectly, we will end up with a monotonically
increasing congestion window.  To see any interesting behavior, we
really want to introduce link errors which will drop packets, cause
duplicate ACKs and trigger the more interesting behaviors of the
congestion window.</p>
<p><em>ns-3</em> provides <code class="docutils literal notranslate"><span class="pre">ErrorModel</span></code> objects which can be attached to
<code class="docutils literal notranslate"><span class="pre">Channels</span></code>.  We are using the <code class="docutils literal notranslate"><span class="pre">RateErrorModel</span></code> which allows us to
introduce errors
into a <code class="docutils literal notranslate"><span class="pre">Channel</span></code> at a given <em>rate</em>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">RateErrorModel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">em</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">RateErrorModel</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">em</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;ErrorRate&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mf">0.00001</span><span class="p">));</span>
<span class="n">devices</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;ReceiveErrorModel&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">PointerValue</span><span class="p">(</span><span class="n">em</span><span class="p">));</span>
</pre></div>
</div>
<p>The above code instantiates a <code class="docutils literal notranslate"><span class="pre">RateErrorModel</span></code> Object, and we set
the “ErrorRate” <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> to the desired value.  We then set the
resulting instantiated <code class="docutils literal notranslate"><span class="pre">RateErrorModel</span></code> as the error model used by
the point-to-point <code class="docutils literal notranslate"><span class="pre">NetDevice</span></code>.  This will give us some
retransmissions and make our plot a little more interesting.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">InternetStackHelper</span><span class="w"> </span><span class="n">stack</span><span class="p">;</span>
<span class="n">stack</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">nodes</span><span class="p">);</span>

<span class="n">Ipv4AddressHelper</span><span class="w"> </span><span class="n">address</span><span class="p">;</span>
<span class="n">address</span><span class="p">.</span><span class="n">SetBase</span><span class="p">(</span><span class="s">&quot;10.1.1.0&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;255.255.255.252&quot;</span><span class="p">);</span>
<span class="n">Ipv4InterfaceContainer</span><span class="w"> </span><span class="n">interfaces</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">Assign</span><span class="p">(</span><span class="n">devices</span><span class="p">);</span>
</pre></div>
</div>
<p>The above code should be familiar.  It installs internet stacks on our
two nodes and creates interfaces and assigns IP addresses for the
point-to-point devices.</p>
<p>Since we are using TCP, we need something on the destination Node to
receive TCP connections and data.  The <code class="docutils literal notranslate"><span class="pre">PacketSink</span></code> <code class="docutils literal notranslate"><span class="pre">Application</span></code>
is commonly used in <em>ns-3</em> for that purpose.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">sinkPort</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8080</span><span class="p">;</span>
<span class="n">Address</span><span class="w"> </span><span class="nf">sinkAddress</span><span class="p">(</span><span class="n">InetSocketAddress</span><span class="p">(</span><span class="n">interfaces</span><span class="p">.</span><span class="n">GetAddress</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">sinkPort</span><span class="p">));</span>
<span class="n">PacketSinkHelper</span><span class="w"> </span><span class="n">packetSinkHelper</span><span class="p">(</span><span class="s">&quot;ns3::TcpSocketFactory&quot;</span><span class="p">,</span>
<span class="w">                                  </span><span class="n">InetSocketAddress</span><span class="p">(</span><span class="n">Ipv4Address</span><span class="o">::</span><span class="n">GetAny</span><span class="p">(),</span><span class="w"> </span><span class="n">sinkPort</span><span class="p">));</span>
<span class="n">ApplicationContainer</span><span class="w"> </span><span class="n">sinkApps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">packetSinkHelper</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">nodes</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="n">sinkApps</span><span class="p">.</span><span class="n">Start</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">0.</span><span class="p">));</span>
<span class="n">sinkApps</span><span class="p">.</span><span class="n">Stop</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">20.</span><span class="p">));</span>
</pre></div>
</div>
<p>This should all be familiar, with the exception of,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">PacketSinkHelper</span><span class="w"> </span><span class="n">packetSinkHelper</span><span class="p">(</span><span class="s">&quot;ns3::TcpSocketFactory&quot;</span><span class="p">,</span>
<span class="w">                                  </span><span class="n">InetSocketAddress</span><span class="p">(</span><span class="n">Ipv4Address</span><span class="o">::</span><span class="n">GetAny</span><span class="p">(),</span><span class="w"> </span><span class="n">sinkPort</span><span class="p">));</span>
</pre></div>
</div>
<p>This code instantiates a <code class="docutils literal notranslate"><span class="pre">PacketSinkHelper</span></code> and tells it to create
sockets using the class <code class="docutils literal notranslate"><span class="pre">ns3::TcpSocketFactory</span></code>.  This class
implements a design pattern called “object factory” which is a
commonly used mechanism for specifying a class used to create objects
in an abstract way.  Here, instead of having to create the objects
themselves, you provide the <code class="docutils literal notranslate"><span class="pre">PacketSinkHelper</span></code> a string that
specifies a <code class="docutils literal notranslate"><span class="pre">TypeId</span></code> string used to create an object which can then
be used, in turn, to create instances of the Objects created by the
factory.</p>
<p>The remaining parameter tells the <code class="docutils literal notranslate"><span class="pre">Application</span></code> which address and
port it should <code class="docutils literal notranslate"><span class="pre">Bind</span></code> to.</p>
<p>The next two lines of code will create the socket and connect the
trace source.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Socket</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ns3TcpSocket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Socket</span><span class="o">::</span><span class="n">CreateSocket</span><span class="p">(</span><span class="n">nodes</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">TcpSocketFactory</span><span class="o">::</span><span class="n">GetTypeId</span><span class="p">());</span>
<span class="n">ns3TcpSocket</span><span class="o">-&gt;</span><span class="n">TraceConnectWithoutContext</span><span class="p">(</span><span class="s">&quot;CongestionWindow&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">MakeCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CwndChange</span><span class="p">));</span>
</pre></div>
</div>
<p>The first statement calls the static member function
<code class="docutils literal notranslate"><span class="pre">Socket::CreateSocket</span></code> and provides a Node and an explicit
<code class="docutils literal notranslate"><span class="pre">TypeId</span></code> for the object factory used to create the socket.  This is
a slightly lower level call than the <code class="docutils literal notranslate"><span class="pre">PacketSinkHelper</span></code> call above,
and uses an explicit C++ type instead of one referred to by a string.
Otherwise, it is conceptually the same thing.</p>
<p>Once the <code class="docutils literal notranslate"><span class="pre">TcpSocket</span></code> is created and attached to the Node, we can
use <code class="docutils literal notranslate"><span class="pre">TraceConnectWithoutContext</span></code> to connect the CongestionWindow
trace source to our trace sink.</p>
<p>Recall that we coded an <code class="docutils literal notranslate"><span class="pre">Application</span></code> so we could take that
<code class="docutils literal notranslate"><span class="pre">Socket</span></code> we just made (during configuration time) and use it in
simulation time.  We now have to instantiate that <code class="docutils literal notranslate"><span class="pre">Application</span></code>.  We
didn’t go to any trouble to create a helper to manage the
<code class="docutils literal notranslate"><span class="pre">Application</span></code> so we are going to have to create and install it
“manually”.  This is actually quite easy:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">TutorialApp</span><span class="o">&gt;</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">TutorialApp</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">app</span><span class="o">-&gt;</span><span class="n">Setup</span><span class="p">(</span><span class="n">ns3TcpSocket</span><span class="p">,</span><span class="w"> </span><span class="n">sinkAddress</span><span class="p">,</span><span class="w"> </span><span class="mi">1040</span><span class="p">,</span><span class="w"> </span><span class="mi">1000</span><span class="p">,</span><span class="w"> </span><span class="n">DataRate</span><span class="p">(</span><span class="s">&quot;1Mbps&quot;</span><span class="p">));</span>
<span class="n">nodes</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">AddApplication</span><span class="p">(</span><span class="n">app</span><span class="p">);</span>
<span class="n">app</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">1.</span><span class="p">));</span>
<span class="n">app</span><span class="o">-&gt;</span><span class="n">Stop</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">20.</span><span class="p">));</span>
</pre></div>
</div>
<p>The first line creates an <code class="docutils literal notranslate"><span class="pre">Object</span></code> of type <code class="docutils literal notranslate"><span class="pre">TutorialApp</span></code> – our
<code class="docutils literal notranslate"><span class="pre">Application</span></code>.  The second line tells the <code class="docutils literal notranslate"><span class="pre">Application</span></code> what
<code class="docutils literal notranslate"><span class="pre">Socket</span></code> to use, what address to connect to, how much data to send
at each send event, how many send events to generate and the rate at
which to produce data from those events.</p>
<p>Next, we manually add the <code class="docutils literal notranslate"><span class="pre">TutorialApp</span> <span class="pre">Application</span></code> to the source Node and
explicitly call the <code class="docutils literal notranslate"><span class="pre">Start</span></code> and <code class="docutils literal notranslate"><span class="pre">Stop</span></code> methods on the
<code class="docutils literal notranslate"><span class="pre">Application</span></code> to tell it when to start and stop doing its thing.</p>
<p>We need to actually do the connect from the receiver point-to-point
<code class="docutils literal notranslate"><span class="pre">NetDevice</span></code> drop event to our <code class="docutils literal notranslate"><span class="pre">RxDrop</span></code> callback now.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">devices</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">TraceConnectWithoutContext</span><span class="p">(</span><span class="s">&quot;PhyRxDrop&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">MakeCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RxDrop</span><span class="p">));</span>
</pre></div>
</div>
<p>It should now be obvious that we are getting a reference to the
receiving <code class="docutils literal notranslate"><span class="pre">Node</span> <span class="pre">NetDevice</span></code> from its container and connecting the
trace source defined by the attribute “PhyRxDrop” on that device to
the trace sink <code class="docutils literal notranslate"><span class="pre">RxDrop</span></code>.</p>
<p>Finally, we tell the simulator to override any <code class="docutils literal notranslate"><span class="pre">Applications</span></code> and
just stop processing events at 20 seconds into the simulation.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Stop</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mi">20</span><span class="p">));</span>
<span class="w">  </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Run</span><span class="p">();</span>
<span class="w">  </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Destroy</span><span class="p">();</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Recall that as soon as <code class="docutils literal notranslate"><span class="pre">Simulator::Run</span></code> is called, configuration
time ends, and simulation time begins.  All of the work we
orchestrated by creating the <code class="docutils literal notranslate"><span class="pre">Application</span></code> and teaching it how to
connect and send data actually happens during this function call.</p>
<p>As soon as <code class="docutils literal notranslate"><span class="pre">Simulator::Run</span></code> returns, the simulation is complete and
we enter the teardown phase.  In this case, <code class="docutils literal notranslate"><span class="pre">Simulator::Destroy</span></code>
takes care of the gory details and we just return a success code after
it completes.</p>
</section>
</section>
<section id="running-fifth-cc">
<h3><span class="section-number">8.3.5. </span>Running <code class="docutils literal notranslate"><span class="pre">fifth.cc</span></code><a class="headerlink" href="#running-fifth-cc" title="Link to this heading">¶</a></h3>
<p>Since we have provided the file <code class="docutils literal notranslate"><span class="pre">fifth.cc</span></code> for you, if you have
built your distribution (in debug or default mode since it uses <code class="docutils literal notranslate"><span class="pre">NS_LOG</span></code> – recall
that optimized builds optimize out <code class="docutils literal notranslate"><span class="pre">NS_LOG</span></code>) it will be waiting for you
to run.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span>fifth
<span class="m">1</span>.00419<span class="w"> </span><span class="m">536</span>
<span class="m">1</span>.0093<span class="w">  </span><span class="m">1072</span>
<span class="m">1</span>.01528<span class="w"> </span><span class="m">1608</span>
<span class="m">1</span>.02167<span class="w"> </span><span class="m">2144</span>
...
<span class="m">1</span>.11319<span class="w"> </span><span class="m">8040</span>
<span class="m">1</span>.12151<span class="w"> </span><span class="m">8576</span>
<span class="m">1</span>.12983<span class="w"> </span><span class="m">9112</span>
RxDrop<span class="w"> </span>at<span class="w"> </span><span class="m">1</span>.13696
...
</pre></div>
</div>
<p>You can probably see immediately a downside of using prints of any
kind in your traces.  We get those extraneous ns3 messages printed all
over our interesting information along with those RxDrop messages.  We
will remedy that soon, but I’m sure you can’t wait to see the results
of all of this work.  Let’s redirect that output to a file called
<code class="docutils literal notranslate"><span class="pre">cwnd.dat</span></code>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span>fifth<span class="w"> </span>&gt;<span class="w"> </span>cwnd.dat<span class="w"> </span><span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span>
</pre></div>
</div>
<p>Now edit up “cwnd.dat” in your favorite editor and remove the ns3
build status and drop lines, leaving only the traced data (you could
also comment out the <code class="docutils literal notranslate"><span class="pre">TraceConnectWithoutContext(&quot;PhyRxDrop&quot;,</span>
<span class="pre">MakeCallback(&amp;RxDrop));</span></code> in the script to get rid of the drop prints
just as easily.</p>
<p>You can now run gnuplot (if you have it installed) and tell it to
generate some pretty pictures:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>gnuplot
gnuplot&gt;<span class="w"> </span><span class="nb">set</span><span class="w"> </span>terminal<span class="w"> </span>png<span class="w"> </span>size<span class="w"> </span><span class="m">640</span>,480
gnuplot&gt;<span class="w"> </span><span class="nb">set</span><span class="w"> </span>output<span class="w"> </span><span class="s2">&quot;cwnd.png&quot;</span>
gnuplot&gt;<span class="w"> </span>plot<span class="w"> </span><span class="s2">&quot;cwnd.dat&quot;</span><span class="w"> </span>using<span class="w"> </span><span class="m">1</span>:2<span class="w"> </span>title<span class="w"> </span><span class="s1">&#39;Congestion Window&#39;</span><span class="w"> </span>with<span class="w"> </span>linespoints
gnuplot&gt;<span class="w"> </span><span class="nb">exit</span>
</pre></div>
</div>
<p>You should now have a graph of the congestion window versus time
sitting in the file “cwnd.png” that looks like:</p>
<figure class="align-default">
<img alt="../../../_images/cwnd.png" src="../../../_images/cwnd.png" />
</figure>
</section>
<section id="using-mid-level-helpers">
<h3><span class="section-number">8.3.6. </span>Using Mid-Level Helpers<a class="headerlink" href="#using-mid-level-helpers" title="Link to this heading">¶</a></h3>
<p>In the previous section, we showed how to hook a trace source and get
hopefully interesting information out of a simulation.  Perhaps you
will recall that we called logging to the standard output using
<code class="docutils literal notranslate"><span class="pre">std::cout</span></code> a “blunt instrument” much earlier in this chapter.  We
also wrote about how it was a problem having to parse the log output
in order to isolate interesting information.  It may have occurred to
you that we just spent a lot of time implementing an example that
exhibits all of the problems we purport to fix with the <em>ns-3</em> tracing
system!  You would be correct.  But, bear with us.  We’re not done
yet.</p>
<p>One of the most important things we want to do is to have the
ability to easily control the amount of output coming out of the
simulation; and we also want to save those data to a file so we can
refer back to it later.  We can use the mid-level trace helpers
provided in <em>ns-3</em> to do just that and complete the picture.</p>
<p>We provide a script that writes the cwnd change and drop events
developed in the example <code class="docutils literal notranslate"><span class="pre">fifth.cc</span></code> to disk in separate files.  The
cwnd changes are stored as a tab-separated ASCII file and the drop
events are stored in a PCAP file.  The changes to make this happen are
quite small.</p>
<section id="walkthrough-sixth-cc">
<h4><span class="section-number">8.3.6.1. </span>Walkthrough: <code class="docutils literal notranslate"><span class="pre">sixth.cc</span></code><a class="headerlink" href="#walkthrough-sixth-cc" title="Link to this heading">¶</a></h4>
<p>Let’s take a look at the changes required to go from <code class="docutils literal notranslate"><span class="pre">fifth.cc</span></code> to
<code class="docutils literal notranslate"><span class="pre">sixth.cc</span></code>.  Open <code class="docutils literal notranslate"><span class="pre">examples/tutorial/sixth.cc</span></code> in your favorite
editor.  You can see the first change by searching for CwndChange.
You will find that we have changed the signatures for the trace sinks
and have added a single line to each sink that writes the traced
information to a stream representing a file.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">CwndChange</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">oldCwnd</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">newCwnd</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">NS_LOG_UNCOND</span><span class="p">(</span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">newCwnd</span><span class="p">);</span>
<span class="w">  </span><span class="o">*</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">GetStream</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">oldCwnd</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">newCwnd</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">RxDrop</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">PcapFileWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Packet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">NS_LOG_UNCOND</span><span class="p">(</span><span class="s">&quot;RxDrop at &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">());</span>
<span class="w">  </span><span class="n">file</span><span class="o">-&gt;</span><span class="n">Write</span><span class="p">(</span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">(),</span><span class="w"> </span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We have added a “stream” parameter to the <code class="docutils literal notranslate"><span class="pre">CwndChange</span></code> trace sink.
This is an object that holds (keeps safely alive) a C++ output stream.
It turns out that this is a very simple object, but one that manages
lifetime issues for the stream and solves a problem that even
experienced C++ users run into.  It turns out that the copy
constructor for <code class="docutils literal notranslate"><span class="pre">std::ostream</span></code> is marked private.  This means that
<code class="docutils literal notranslate"><span class="pre">std::ostreams</span></code> do not obey value semantics and cannot be used in
any mechanism that requires the stream to be copied.  This includes
the <em>ns-3</em> callback system, which as you may recall, requires objects
that obey value semantics.  Further notice that we have added the
following line in the <code class="docutils literal notranslate"><span class="pre">CwndChange</span></code> trace sink implementation:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">*</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">GetStream</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">oldCwnd</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">newCwnd</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>This would be very familiar code if you replaced <code class="docutils literal notranslate"><span class="pre">*stream-&gt;GetStream()</span></code> with <code class="docutils literal notranslate"><span class="pre">std::cout</span></code>, as in:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">oldCwnd</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">newCwnd</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>This illustrates that the <code class="docutils literal notranslate"><span class="pre">Ptr&lt;OutputStreamWrapper&gt;</span></code> is really just
carrying around a <code class="docutils literal notranslate"><span class="pre">std::ofstream</span></code> for you, and you can use it here
like any other output stream.</p>
<p>A similar situation happens in <code class="docutils literal notranslate"><span class="pre">RxDrop</span></code> except that the object being
passed around (a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;PcapFileWrapper&gt;</span></code>) represents a PCAP file.
There is a one-liner in the trace sink to write a timestamp and the
contents of the packet being dropped to the PCAP file:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">file</span><span class="o">-&gt;</span><span class="n">Write</span><span class="p">(</span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">(),</span><span class="w"> </span><span class="n">p</span><span class="p">);</span>
</pre></div>
</div>
<p>Of course, if we have objects representing the two files, we need to
create them somewhere and also cause them to be passed to the trace
sinks.  If you look in the <code class="docutils literal notranslate"><span class="pre">main</span></code> function, you will find new code
to do just that:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">AsciiTraceHelper</span><span class="w"> </span><span class="n">asciiTraceHelper</span><span class="p">;</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">asciiTraceHelper</span><span class="p">.</span><span class="n">CreateFileStream</span><span class="p">(</span><span class="s">&quot;sixth.cwnd&quot;</span><span class="p">);</span>
<span class="n">ns3TcpSocket</span><span class="o">-&gt;</span><span class="n">TraceConnectWithoutContext</span><span class="p">(</span><span class="s">&quot;CongestionWindow&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">MakeBoundCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CwndChange</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">));</span>

<span class="p">...</span>

<span class="n">PcapHelper</span><span class="w"> </span><span class="n">pcapHelper</span><span class="p">;</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">PcapFileWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pcapHelper</span><span class="p">.</span><span class="n">CreateFile</span><span class="p">(</span><span class="s">&quot;sixth.pcap&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">PcapHelper</span><span class="o">::</span><span class="n">DLT_PPP</span><span class="p">);</span>
<span class="n">devices</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">TraceConnectWithoutContext</span><span class="p">(</span><span class="s">&quot;PhyRxDrop&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">MakeBoundCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RxDrop</span><span class="p">,</span><span class="w"> </span><span class="n">file</span><span class="p">));</span>
</pre></div>
</div>
<p>In the first section of the code snippet above, we are creating the
ASCII trace file, creating an object responsible for managing it and
using a variant of the callback creation function to arrange for the
object to be passed to the sink.  Our ASCII trace helpers provide a
rich set of functions to make using text (ASCII) files easy.  We are
just going to illustrate the use of the file stream creation function
here.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">CreateFileStream</span></code> function is basically going to instantiate
a <code class="docutils literal notranslate"><span class="pre">std::ofstream</span></code> object and create a new file (or truncate an existing
file).  This <code class="docutils literal notranslate"><span class="pre">std::ofstream</span></code> is packaged up in an <em>ns-3</em> object for lifetime
management and copy constructor issue resolution.</p>
<p>We then take this <em>ns-3</em> object representing the file and pass it to
<code class="docutils literal notranslate"><span class="pre">MakeBoundCallback()</span></code>.  This function creates a callback just like
<code class="docutils literal notranslate"><span class="pre">MakeCallback()</span></code>, but it “binds” a new value to the callback.  This
value is added as the first argument to the callback before it is called.</p>
<p>Essentially, <code class="docutils literal notranslate"><span class="pre">MakeBoundCallback(&amp;CwndChange,</span> <span class="pre">stream)</span></code> causes the
trace source to add the additional “stream” parameter to the front of
the formal parameter list before invoking the callback.  This changes
the required signature of the <code class="docutils literal notranslate"><span class="pre">CwndChange</span></code> sink to match the one
shown above, which includes the “extra” parameter
<code class="docutils literal notranslate"><span class="pre">Ptr&lt;OutputStreamWrapper&gt;</span> <span class="pre">stream</span></code>.</p>
<p>In the second section of code in the snippet above, we instantiate a
<code class="docutils literal notranslate"><span class="pre">PcapHelper</span></code> to do the same thing for our PCAP trace file that we
did with the <code class="docutils literal notranslate"><span class="pre">AsciiTraceHelper</span></code>. The line of code,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">PcapFileWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pcapHelper</span><span class="p">.</span><span class="n">CreateFile</span><span class="p">(</span><span class="s">&quot;sixth.pcap&quot;</span><span class="p">,</span>
<span class="s">&quot;w&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">PcapHelper</span><span class="o">::</span><span class="n">DLT_PPP</span><span class="p">);</span>
</pre></div>
</div>
<p>creates a PCAP file named “sixth.pcap” with file mode “w”.  This means
that the new file is truncated (contents deleted) if an existing file
with that name is found.  The final parameter is the “data link type”
of the new PCAP file.  These are the same as the PCAP library data
link types defined in <code class="docutils literal notranslate"><span class="pre">bpf.h</span></code> if you are familiar with PCAP.  In this
case, <code class="docutils literal notranslate"><span class="pre">DLT_PPP</span></code> indicates that the PCAP file is going to contain
packets prefixed with point to point headers.  This is true since the
packets are coming from our point-to-point device driver.  Other
common data link types are DLT_EN10MB (10 MB Ethernet) appropriate for
csma devices and DLT_IEEE802_11 (IEEE 802.11) appropriate for wifi
devices.  These are defined in <code class="docutils literal notranslate"><span class="pre">src/network/helper/trace-helper.h</span></code>
if you are interested in seeing the list.  The entries in the list
match those in <code class="docutils literal notranslate"><span class="pre">bpf.h</span></code> but we duplicate them to avoid a PCAP source
dependence.</p>
<p>A <em>ns-3</em> object representing the PCAP file is returned from
<code class="docutils literal notranslate"><span class="pre">CreateFile</span></code> and used in a bound callback exactly as it was in the
ASCII case.</p>
<p>An important detour: It is important to notice that even though both
of these objects are declared in very similar ways,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">PcapFileWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="p">...</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="p">...</span>
</pre></div>
</div>
<p>The underlying objects are entirely different.  For example, the
<code class="docutils literal notranslate"><span class="pre">Ptr&lt;PcapFileWrapper&gt;</span></code> is a smart pointer to an <em>ns-3</em> Object that is
a fairly heavyweight thing that supports Attributes and is integrated
into the Config system.  The <code class="docutils literal notranslate"><span class="pre">Ptr&lt;OutputStreamWrapper&gt;</span></code>, on the
other hand, is a smart pointer to a reference counted object that is a
very lightweight thing.  Remember to look at the object you are
referencing before making any assumptions about the “powers” that
object may have.</p>
<p>For example, take a look at <code class="docutils literal notranslate"><span class="pre">src/network/utils/pcap-file-wrapper.h</span></code>
in the distribution and notice,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">PcapFileWrapper</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Object</span>
</pre></div>
</div>
<p>that class <code class="docutils literal notranslate"><span class="pre">PcapFileWrapper</span></code> is an <em>ns-3</em> Object by virtue of its
inheritance.  Then look at
<code class="docutils literal notranslate"><span class="pre">src/network/model/output-stream-wrapper.h</span></code> and notice,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">OutputStreamWrapper</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span>
<span class="n">SimpleRefCount</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>that this object is not an <em>ns-3</em> Object at all, it is “merely” a C++
object that happens to support intrusive reference counting.</p>
<p>The point here is that just because you read <code class="docutils literal notranslate"><span class="pre">Ptr&lt;something&gt;</span></code> it does
not necessarily mean that <code class="docutils literal notranslate"><span class="pre">something</span></code> is an <em>ns-3</em> Object on which you
can hang <em>ns-3</em> Attributes, for example.</p>
<p>Now, back to the example.  If you build and run this example,</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span>sixth
</pre></div>
</div>
<p>you will see the same messages appear as when you ran “fifth”, but two
new files will appear in the top-level directory of your <em>ns-3</em>
distribution.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>sixth.cwnd<span class="w">  </span>sixth.pcap
</pre></div>
</div>
<p>Since “sixth.cwnd” is an ASCII text file, you can view it with <code class="docutils literal notranslate"><span class="pre">cat</span></code>
or your favorite file viewer.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="m">1</span><span class="w">       </span><span class="m">0</span><span class="w">       </span><span class="m">536</span>
<span class="m">1</span>.0093<span class="w">  </span><span class="m">536</span><span class="w">     </span><span class="m">1072</span>
<span class="m">1</span>.01528<span class="w"> </span><span class="m">1072</span><span class="w">    </span><span class="m">1608</span>
<span class="m">1</span>.02167<span class="w"> </span><span class="m">1608</span><span class="w">    </span><span class="m">2144</span>
...
<span class="m">9</span>.69256<span class="w"> </span><span class="m">5149</span><span class="w">    </span><span class="m">5204</span>
<span class="m">9</span>.89311<span class="w"> </span><span class="m">5204</span><span class="w">    </span><span class="m">5259</span>
</pre></div>
</div>
<p>You have a tab separated file with a timestamp, an old congestion
window and a new congestion window suitable for directly importing
into your plot program.  There are no extraneous prints in the file,
no parsing or editing is required.</p>
<p>Since “sixth.pcap” is a PCAP file, you can view it with <code class="docutils literal notranslate"><span class="pre">tcpdump</span></code>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>reading<span class="w"> </span>from<span class="w"> </span>file<span class="w"> </span>sixth.pcap,<span class="w"> </span>link-type<span class="w"> </span>PPP<span class="w"> </span><span class="o">(</span>PPP<span class="o">)</span>
<span class="m">1</span>.136956<span class="w"> </span>IP<span class="w"> </span><span class="m">10</span>.1.1.1.49153<span class="w"> </span>&gt;<span class="w"> </span><span class="m">10</span>.1.1.2.8080:<span class="w"> </span>Flags<span class="w"> </span><span class="o">[</span>.<span class="o">]</span>,<span class="w"> </span>seq<span class="w"> </span><span class="m">17177</span>:17681,<span class="w"> </span>ack<span class="w"> </span><span class="m">1</span>,<span class="w"> </span>win<span class="w"> </span><span class="m">32768</span>,<span class="w"> </span>options<span class="w"> </span><span class="o">[</span>TS<span class="w"> </span>val<span class="w"> </span><span class="m">1133</span><span class="w"> </span>ecr<span class="w"> </span><span class="m">1127</span>,eol<span class="o">]</span>,<span class="w"> </span>length<span class="w"> </span><span class="m">504</span>
<span class="m">1</span>.403196<span class="w"> </span>IP<span class="w"> </span><span class="m">10</span>.1.1.1.49153<span class="w"> </span>&gt;<span class="w"> </span><span class="m">10</span>.1.1.2.8080:<span class="w"> </span>Flags<span class="w"> </span><span class="o">[</span>.<span class="o">]</span>,<span class="w"> </span>seq<span class="w"> </span><span class="m">33280</span>:33784,<span class="w"> </span>ack<span class="w"> </span><span class="m">1</span>,<span class="w"> </span>win<span class="w"> </span><span class="m">32768</span>,<span class="w"> </span>options<span class="w"> </span><span class="o">[</span>TS<span class="w"> </span>val<span class="w"> </span><span class="m">1399</span><span class="w"> </span>ecr<span class="w"> </span><span class="m">1394</span>,eol<span class="o">]</span>,<span class="w"> </span>length<span class="w"> </span><span class="m">504</span>
...
<span class="m">7</span>.426220<span class="w"> </span>IP<span class="w"> </span><span class="m">10</span>.1.1.1.49153<span class="w"> </span>&gt;<span class="w"> </span><span class="m">10</span>.1.1.2.8080:<span class="w"> </span>Flags<span class="w"> </span><span class="o">[</span>.<span class="o">]</span>,<span class="w"> </span>seq<span class="w"> </span><span class="m">785704</span>:786240,<span class="w"> </span>ack<span class="w"> </span><span class="m">1</span>,<span class="w"> </span>win<span class="w"> </span><span class="m">32768</span>,<span class="w"> </span>options<span class="w"> </span><span class="o">[</span>TS<span class="w"> </span>val<span class="w"> </span><span class="m">7423</span><span class="w"> </span>ecr<span class="w"> </span><span class="m">7421</span>,eol<span class="o">]</span>,<span class="w"> </span>length<span class="w"> </span><span class="m">536</span>
<span class="m">9</span>.630693<span class="w"> </span>IP<span class="w"> </span><span class="m">10</span>.1.1.1.49153<span class="w"> </span>&gt;<span class="w"> </span><span class="m">10</span>.1.1.2.8080:<span class="w"> </span>Flags<span class="w"> </span><span class="o">[</span>.<span class="o">]</span>,<span class="w"> </span>seq<span class="w"> </span><span class="m">882688</span>:883224,<span class="w"> </span>ack<span class="w"> </span><span class="m">1</span>,<span class="w"> </span>win<span class="w"> </span><span class="m">32768</span>,<span class="w"> </span>options<span class="w"> </span><span class="o">[</span>TS<span class="w"> </span>val<span class="w"> </span><span class="m">9620</span><span class="w"> </span>ecr<span class="w"> </span><span class="m">9618</span>,eol<span class="o">]</span>,<span class="w"> </span>length<span class="w"> </span><span class="m">536</span>
</pre></div>
</div>
<p>You have a PCAP file with the packets that were dropped in the
simulation.  There are no other packets present in the file and there
is nothing else present to make life difficult.</p>
<p>It’s been a long journey, but we are now at a point where we can
appreciate the <em>ns-3</em> tracing system.  We have pulled important events
out of the middle of a TCP implementation and a device driver.  We
stored those events directly in files usable with commonly known
tools.  We did this without modifying any of the core code involved,
and we did this in only 18 lines of code:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">CwndChange</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">oldCwnd</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">newCwnd</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">NS_LOG_UNCOND</span><span class="p">(</span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">newCwnd</span><span class="p">);</span>
<span class="w">  </span><span class="o">*</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">GetStream</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">oldCwnd</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">newCwnd</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="n">AsciiTraceHelper</span><span class="w"> </span><span class="n">asciiTraceHelper</span><span class="p">;</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">asciiTraceHelper</span><span class="p">.</span><span class="n">CreateFileStream</span><span class="p">(</span><span class="s">&quot;sixth.cwnd&quot;</span><span class="p">);</span>
<span class="n">ns3TcpSocket</span><span class="o">-&gt;</span><span class="n">TraceConnectWithoutContext</span><span class="p">(</span><span class="s">&quot;CongestionWindow&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">MakeBoundCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CwndChange</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">));</span>

<span class="p">...</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="n">RxDrop</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">PcapFileWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Packet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">NS_LOG_UNCOND</span><span class="p">(</span><span class="s">&quot;RxDrop at &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">());</span>
<span class="w">  </span><span class="n">file</span><span class="o">-&gt;</span><span class="n">Write</span><span class="p">(</span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">(),</span><span class="w"> </span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="n">PcapHelper</span><span class="w"> </span><span class="n">pcapHelper</span><span class="p">;</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">PcapFileWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pcapHelper</span><span class="p">.</span><span class="n">CreateFile</span><span class="p">(</span><span class="s">&quot;sixth.pcap&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">PcapHelper</span><span class="o">::</span><span class="n">DLT_PPP</span><span class="p">);</span>
<span class="n">devices</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">TraceConnectWithoutContext</span><span class="p">(</span><span class="s">&quot;PhyRxDrop&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">MakeBoundCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RxDrop</span><span class="p">,</span><span class="w"> </span><span class="n">file</span><span class="p">));</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="trace-helpers">
<h2><span class="section-number">8.4. </span>Trace Helpers<a class="headerlink" href="#trace-helpers" title="Link to this heading">¶</a></h2>
<p>The <em>ns-3</em> trace helpers provide a rich environment for configuring and
selecting different trace events and writing them to files.  In
previous sections, primarily <a class="reference internal" href="building-topologies.html#buildingtopologies"><span class="std std-ref">Building Topologies</span></a>, we have seen
several varieties of the trace helper methods designed for use inside
other (device) helpers.</p>
<p>Perhaps you will recall seeing some of these variations:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">pointToPoint</span><span class="p">.</span><span class="n">EnablePcapAll</span><span class="p">(</span><span class="s">&quot;second&quot;</span><span class="p">);</span>
<span class="n">pointToPoint</span><span class="p">.</span><span class="n">EnablePcap</span><span class="p">(</span><span class="s">&quot;second&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">p2pNodes</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetId</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">csma</span><span class="p">.</span><span class="n">EnablePcap</span><span class="p">(</span><span class="s">&quot;third&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">csmaDevices</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="n">pointToPoint</span><span class="p">.</span><span class="n">EnableAsciiAll</span><span class="p">(</span><span class="n">ascii</span><span class="p">.</span><span class="n">CreateFileStream</span><span class="p">(</span><span class="s">&quot;myfirst.tr&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>What may not be obvious, though, is that there is a consistent model
for all of the trace-related methods found in the system.  We will now
take a little time and take a look at the “big picture”.</p>
<p>There are currently two primary use cases of the tracing helpers in
<em>ns-3</em>:  device helpers and protocol helpers.  Device helpers look at
the problem of specifying which traces should be enabled through a
(node, device) pair.  For example, you may want to specify that PCAP
tracing should be enabled on a particular device on a specific node.
This follows from the <em>ns-3</em> device conceptual model, and also the
conceptual models of the various device helpers.  Following naturally
from this, the files created follow a <code class="docutils literal notranslate"><span class="pre">&lt;prefix&gt;-&lt;node&gt;-&lt;device&gt;</span></code> naming
convention.</p>
<p>Protocol helpers look at the problem of specifying which traces should
be enabled through a protocol and interface pair.  This follows from
the <em>ns-3</em> protocol stack conceptual model, and also the conceptual
models of internet stack helpers.  Naturally, the trace files should
follow a <code class="docutils literal notranslate"><span class="pre">&lt;prefix&gt;-&lt;protocol&gt;-&lt;interface&gt;</span></code> naming convention.</p>
<p>The trace helpers therefore fall naturally into a two-dimensional
taxonomy.  There are subtleties that prevent all four classes from
behaving identically, but we do strive to make them all work as
similarly as possible; and whenever possible there are analogs for all
methods in all classes.</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p>PCAP</p></th>
<th class="head"><p>ASCII</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Device Helper</p></td>
<td><p><span class="math notranslate nohighlight">\(\checkmark\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\checkmark\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>Protocol Helper</p></td>
<td><p><span class="math notranslate nohighlight">\(\checkmark\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\checkmark\)</span></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>We use an approach called a <code class="docutils literal notranslate"><span class="pre">mixin</span></code> to add tracing functionality to
our helper classes.  A <code class="docutils literal notranslate"><span class="pre">mixin</span></code> is a class that provides
functionality when it is inherited by a subclass.  Inheriting from a
mixin is not considered a form of specialization but is really a way
to collect functionality.</p>
<p>Let’s take a quick look at all four of these cases and their
respective <code class="docutils literal notranslate"><span class="pre">mixins</span></code>.</p>
<section id="device-helpers">
<h3><span class="section-number">8.4.1. </span>Device Helpers<a class="headerlink" href="#device-helpers" title="Link to this heading">¶</a></h3>
<section id="pcap">
<h4><span class="section-number">8.4.1.1. </span>PCAP<a class="headerlink" href="#pcap" title="Link to this heading">¶</a></h4>
<p>The goal of these helpers is to make it easy to add a consistent PCAP
trace facility to an <em>ns-3</em> device.  We want all of the various flavors
of PCAP tracing to work the same across all devices, so the methods of
these helpers are inherited by device helpers.  Take a look at
<code class="docutils literal notranslate"><span class="pre">src/network/helper/trace-helper.h</span></code> if you want to follow the
discussion while looking at real code.</p>
<p>The class <code class="docutils literal notranslate"><span class="pre">PcapHelperForDevice</span></code> is a <code class="docutils literal notranslate"><span class="pre">mixin</span></code> provides the high
level functionality for using PCAP tracing in an <em>ns-3</em> device.  Every
device must implement a single virtual method inherited from this
class.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcapInternal</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">promiscuous</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>The signature of this method reflects the device-centric view of the
situation at this level.  All of the public methods inherited from
class <code class="docutils literal notranslate"><span class="pre">PcapUserHelperForDevice</span></code> reduce to calling this single
device-dependent implementation method.  For example, the lowest level
PCAP method,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">promiscuous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
</pre></div>
</div>
<p>will call the device implementation of <code class="docutils literal notranslate"><span class="pre">EnablePcapInternal</span></code>
directly.  All other public PCAP tracing methods build on this
implementation to provide additional user-level functionality.  What
this means to the user is that all device helpers in the system will
have all of the PCAP trace methods available; and these methods will
all work in the same way across devices if the device implements
<code class="docutils literal notranslate"><span class="pre">EnablePcapInternal</span></code> correctly.</p>
<section id="methods">
<h5><span class="section-number">8.4.1.1.1. </span>Methods<a class="headerlink" href="#methods" title="Link to this heading">¶</a></h5>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">promiscuous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">ndName</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">promiscuous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">promiscuous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">promiscuous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">nodeid</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">deviceid</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">promiscuous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcapAll</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">promiscuous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
</pre></div>
</div>
<p>In each of the methods shown above, there is a default parameter
called <code class="docutils literal notranslate"><span class="pre">promiscuous</span></code> that defaults to <code class="docutils literal notranslate"><span class="pre">false</span></code>.  This parameter
indicates that the trace should not be gathered in promiscuous mode.
If you do want your traces to include all traffic seen by the device
(and if the device supports a promiscuous mode) simply add a true
parameter to any of the calls above.  For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnablePcap</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">nd</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
<p>will enable promiscuous mode captures on the <code class="docutils literal notranslate"><span class="pre">NetDevice</span></code> specified
by <code class="docutils literal notranslate"><span class="pre">nd</span></code>.</p>
<p>The first two methods also include a default parameter called
<code class="docutils literal notranslate"><span class="pre">explicitFilename</span></code> that will be discussed below.</p>
<p>You are encouraged to peruse the API Documentation for class
<code class="docutils literal notranslate"><span class="pre">PcapHelperForDevice</span></code> to find the details of these methods; but to
summarize …</p>
<ul>
<li><p>You can enable PCAP tracing on a particular node/net-device pair by
providing a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;NetDevice&gt;</span></code> to an <code class="docutils literal notranslate"><span class="pre">EnablePcap</span></code> method.  The
<code class="docutils literal notranslate"><span class="pre">Ptr&lt;Node&gt;</span></code> is implicit since the net device must belong to exactly
one Node.  For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnablePcap</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">nd</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>You can enable PCAP tracing on a particular node/net-device pair by
providing a <code class="docutils literal notranslate"><span class="pre">std::string</span></code> representing an object name service string
to an <code class="docutils literal notranslate"><span class="pre">EnablePcap</span></code> method.  The <code class="docutils literal notranslate"><span class="pre">Ptr&lt;NetDevice&gt;</span></code> is looked up from
the name string.  Again, the <code class="docutils literal notranslate"><span class="pre">&lt;Node&gt;</span></code> is implicit since the named
net device must belong to exactly one Node.  For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;server&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;server/eth0&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnablePcap</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;server/ath0&quot;</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>You can enable PCAP tracing on a collection of node/net-device pairs
by providing a <code class="docutils literal notranslate"><span class="pre">NetDeviceContainer</span></code>.  For each <code class="docutils literal notranslate"><span class="pre">NetDevice</span></code> in the
container the type is checked.  For each device of the proper type
(the same type as is managed by the device helper), tracing is
enabled.  Again, the <code class="docutils literal notranslate"><span class="pre">&lt;Node&gt;</span></code> is implicit since the found net device
must belong to exactly one Node.  For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnablePcap</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>You can enable PCAP tracing on a collection of node/net-device pairs
by providing a <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code>.  For each Node in the
<code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code> its attached <code class="docutils literal notranslate"><span class="pre">NetDevices</span></code> are iterated.  For each
<code class="docutils literal notranslate"><span class="pre">NetDevice</span></code> attached to each Node in the container, the type of that
device is checked.  For each device of the proper type (the same type
as is managed by the device helper), tracing is enabled.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnablePcap</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>You can enable PCAP tracing on the basis of Node ID and device ID as
well as with explicit <code class="docutils literal notranslate"><span class="pre">Ptr</span></code>.  Each Node in the system has an
integer Node ID and each device connected to a Node has an integer
device ID.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">helper</span><span class="p">.</span><span class="n">EnablePcap</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>Finally, you can enable PCAP tracing for all devices in the system,
with the same type as that managed by the device helper.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">helper</span><span class="p">.</span><span class="n">EnablePcapAll</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="filenames">
<h5><span class="section-number">8.4.1.1.2. </span>Filenames<a class="headerlink" href="#filenames" title="Link to this heading">¶</a></h5>
<p>Implicit in the method descriptions above is the construction of a
complete filename by the implementation method.  By convention, PCAP
traces in the <em>ns-3</em> system are of the form <code class="docutils literal notranslate"><span class="pre">&lt;prefix&gt;-&lt;node</span> <span class="pre">id&gt;-&lt;device</span>
<span class="pre">id&gt;.pcap</span></code></p>
<p>As previously mentioned, every Node in the system will have a
system-assigned Node id; and every device will have an interface index
(also called a device id) relative to its node.  By default, then, a
PCAP trace file created as a result of enabling tracing on the first
device of Node 21 using the prefix “prefix” would be
<code class="docutils literal notranslate"><span class="pre">prefix-21-1.pcap</span></code>.</p>
<p>You can always use the <em>ns-3</em> object name service to make this more
clear.  For example, if you use the object name service to assign the
name “server” to Node 21, the resulting PCAP trace file name will
automatically become, <code class="docutils literal notranslate"><span class="pre">prefix-server-1.pcap</span></code> and if you also assign
the name “eth0” to the device, your PCAP file name will automatically
pick this up and be called <code class="docutils literal notranslate"><span class="pre">prefix-server-eth0.pcap</span></code>.</p>
<p>Finally, two of the methods shown above,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">promiscuous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">ndName</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">promiscuous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
</pre></div>
</div>
<p>have a default parameter called <code class="docutils literal notranslate"><span class="pre">explicitFilename</span></code>.  When set to
true, this parameter disables the automatic filename completion
mechanism and allows you to create an explicit filename.  This option
is only available in the methods which enable PCAP tracing on a single
device.</p>
<p>For example, in order to arrange for a device helper to create a
single promiscuous PCAP capture file of a specific name
<code class="docutils literal notranslate"><span class="pre">my-pcap-file.pcap</span></code> on a given device, one could:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnablePcap</span><span class="p">(</span><span class="s">&quot;my-pcap-file.pcap&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">nd</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
<p>The first <code class="docutils literal notranslate"><span class="pre">true</span></code> parameter enables promiscuous mode traces and the
second tells the helper to interpret the <code class="docutils literal notranslate"><span class="pre">prefix</span></code> parameter as a
complete filename.</p>
</section>
</section>
<section id="ascii">
<h4><span class="section-number">8.4.1.2. </span>ASCII<a class="headerlink" href="#ascii" title="Link to this heading">¶</a></h4>
<p>The behavior of the ASCII trace helper <code class="docutils literal notranslate"><span class="pre">mixin</span></code> is substantially
similar to the PCAP version.  Take a look at
<code class="docutils literal notranslate"><span class="pre">src/network/helper/trace-helper.h</span></code> if you want to follow the
discussion while looking at real code.</p>
<p>The class <code class="docutils literal notranslate"><span class="pre">AsciiTraceHelperForDevice</span></code> adds the high level
functionality for using ASCII tracing to a device helper class.  As in
the PCAP case, every device must implement a single virtual method
inherited from the ASCII trace <code class="docutils literal notranslate"><span class="pre">mixin</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiInternal</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span>
<span class="w">                                 </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span>
<span class="w">                                 </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">,</span>
<span class="w">                                 </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>The signature of this method reflects the device-centric view of the
situation at this level; and also the fact that the helper may be
writing to a shared output stream.  All of the public
ASCII-trace-related methods inherited from class
<code class="docutils literal notranslate"><span class="pre">AsciiTraceHelperForDevice</span></code> reduce to calling this single device-
dependent implementation method.  For example, the lowest level ascii
trace methods,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">);</span>
</pre></div>
</div>
<p>will call the device implementation of <code class="docutils literal notranslate"><span class="pre">EnableAsciiInternal</span></code>
directly, providing either a valid prefix or stream.  All other public
ASCII tracing methods will build on these low-level functions to
provide additional user-level functionality.  What this means to the
user is that all device helpers in the system will have all of the
ASCII trace methods available; and these methods will all work in the
same way across devices if the devices implement
<code class="docutils literal notranslate"><span class="pre">EnableAsciiInternal</span></code> correctly.</p>
<section id="id2">
<h5><span class="section-number">8.4.1.2.1. </span>Methods<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h5>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">ndName</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">ndName</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiAll</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiAll</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">nodeid</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">deviceid</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">nodeid</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">deviceid</span><span class="p">);</span>
</pre></div>
</div>
<p>You are encouraged to peruse the API Documentation for class
<code class="docutils literal notranslate"><span class="pre">AsciiTraceHelperForDevice</span></code> to find the details of these methods;
but to summarize …</p>
<ul class="simple">
<li><p>There are twice as many methods available for ASCII tracing as
there were for PCAP tracing.  This is because, in addition to the
PCAP-style model where traces from each unique node/device pair are
written to a unique file, we support a model in which trace
information for many node/device pairs is written to a common file.
This means that the &lt;prefix&gt;-&lt;node&gt;-&lt;device&gt; file name generation
mechanism is replaced by a mechanism to refer to a common file; and
the number of API methods is doubled to allow all combinations.</p></li>
<li><p>Just as in PCAP tracing, you can enable ASCII tracing on a
particular (node, net-device) pair by providing a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;NetDevice&gt;</span></code>
to an <code class="docutils literal notranslate"><span class="pre">EnableAscii</span></code> method.  The <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Node&gt;</span></code> is implicit since
the net device must belong to exactly one Node.  For example,</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAscii</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">nd</span><span class="p">);</span>
</pre></div>
</div>
<ul>
<li><p>The first four methods also include a default parameter called
<code class="docutils literal notranslate"><span class="pre">explicitFilename</span></code> that operate similar to equivalent parameters
in the PCAP case.</p>
<p>In this case, no trace contexts are written to the ASCII trace file
since they would be redundant.  The system will pick the file name
to be created using the same rules as described in the PCAP section,
except that the file will have the suffix <code class="docutils literal notranslate"><span class="pre">.tr</span></code> instead of
<code class="docutils literal notranslate"><span class="pre">.pcap</span></code>.</p>
</li>
<li><p>If you want to enable ASCII tracing on more than one net device
and have all traces sent to a single file, you can do that as well
by using an object to refer to a single file.  We have already seen
this in the “cwnd” example above:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd1</span><span class="p">;</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd2</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">asciiTraceHelper</span><span class="p">.</span><span class="n">CreateFileStream</span><span class="p">(</span><span class="s">&quot;trace-file-name.tr&quot;</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAscii</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">nd1</span><span class="p">);</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAscii</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">nd2</span><span class="p">);</span>
</pre></div>
</div>
<p>In this case, trace contexts <em>are</em> written to the ASCII trace file
since they are required to disambiguate traces from the two devices.
Note that since the user is completely specifying the file name, the
string should include the <code class="docutils literal notranslate"><span class="pre">,tr</span></code> suffix for consistency.</p>
</li>
<li><p>You can enable ASCII tracing on a particular (node, net-device)
pair by providing a <code class="docutils literal notranslate"><span class="pre">std::string</span></code> representing an object name
service string to an <code class="docutils literal notranslate"><span class="pre">EnablePcap</span></code> method.  The <code class="docutils literal notranslate"><span class="pre">Ptr&lt;NetDevice&gt;</span></code>
is looked up from the name string.  Again, the <code class="docutils literal notranslate"><span class="pre">&lt;Node&gt;</span></code> is
implicit since the named net device must belong to exactly one Node.
For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;client&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;client/eth0&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;server&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;server/eth0&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAscii</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;client/eth0&quot;</span><span class="p">);</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAscii</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;server/eth0&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>This would result in two files named <code class="docutils literal notranslate"><span class="pre">prefix-client-eth0.tr</span></code> and
<code class="docutils literal notranslate"><span class="pre">prefix-server-eth0.tr</span></code> with traces for each device in the
respective trace file.  Since all of the <code class="docutils literal notranslate"><span class="pre">EnableAscii</span></code> functions
are overloaded to take a stream wrapper, you can use that form as
well:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;client&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;client/eth0&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;server&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;server/eth0&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="p">...</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">asciiTraceHelper</span><span class="p">.</span><span class="n">CreateFileStream</span><span class="p">(</span><span class="s">&quot;trace-file-name.tr&quot;</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAscii</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;client/eth0&quot;</span><span class="p">);</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAscii</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;server/eth0&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>This would result in a single trace file called
<code class="docutils literal notranslate"><span class="pre">trace-file-name.tr</span></code> that contains all of the trace events for
both devices.  The events would be disambiguated by trace context
strings.</p>
</li>
<li><p>You can enable ASCII tracing on a collection of (node, net-device)
pairs by providing a <code class="docutils literal notranslate"><span class="pre">NetDeviceContainer</span></code>.  For each <code class="docutils literal notranslate"><span class="pre">NetDevice</span></code>
in the container the type is checked.  For each device of the proper
type (the same type as is managed by the device helper), tracing is
enabled.  Again, the <code class="docutils literal notranslate"><span class="pre">&lt;Node&gt;</span></code> is implicit since the found net
device must belong to exactly one Node.  For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAscii</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
</pre></div>
</div>
<p>This would result in a number of ASCII trace files being created,
each of which follows the <code class="docutils literal notranslate"><span class="pre">&lt;prefix&gt;-&lt;node</span> <span class="pre">id&gt;-&lt;device</span> <span class="pre">id&gt;.tr</span></code>
convention.</p>
<p>Combining all of the traces into a single file is accomplished
similarly to the examples above:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="p">...</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">asciiTraceHelper</span><span class="p">.</span><span class="n">CreateFileStream</span><span class="p">(</span><span class="s">&quot;trace-file-name.tr&quot;</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAscii</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>You can enable ASCII tracing on a collection of (node, net-device)
pairs by providing a <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code>.  For each Node in the
<code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code> its attached <code class="docutils literal notranslate"><span class="pre">NetDevices</span></code> are iterated.  For
each <code class="docutils literal notranslate"><span class="pre">NetDevice</span></code> attached to each Node in the container, the type
of that device is checked.  For each device of the proper type (the
same type as is managed by the device helper), tracing is enabled.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAscii</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
<p>This would result in a number of ASCII trace files being created,
each of which follows the <code class="docutils literal notranslate"><span class="pre">&lt;prefix&gt;-&lt;node</span> <span class="pre">id&gt;-&lt;device</span> <span class="pre">id&gt;.tr</span></code>
convention.  Combining all of the traces into a single file is
accomplished similarly to the examples above.</p>
</li>
<li><p>You can enable ASCII tracing on the basis of Node ID and device ID
as well as with explicit <code class="docutils literal notranslate"><span class="pre">Ptr</span></code>.  Each Node in the system has an
integer Node ID and each device connected to a Node has an integer
device ID.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">helper</span><span class="p">.</span><span class="n">EnableAscii</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>Of course, the traces can be combined into a single file as shown
above.</p>
</li>
<li><p>Finally, you can enable ASCII tracing for all devices in the
system, with the same type as that managed by the device helper.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiAll</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>This would result in a number of ASCII trace files being created,
one for every device in the system of the type managed by the
helper.  All of these files will follow the <code class="docutils literal notranslate"><span class="pre">&lt;prefix&gt;-&lt;node</span>
<span class="pre">id&gt;-&lt;device</span> <span class="pre">id&gt;.tr</span></code> convention.  Combining all of the traces into a
single file is accomplished similarly to the examples above.</p>
</li>
</ul>
</section>
<section id="id3">
<h5><span class="section-number">8.4.1.2.2. </span>Filenames<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h5>
<p>Implicit in the prefix-style method descriptions above is the
construction of the complete filenames by the implementation method.
By convention, ASCII traces in the <em>ns-3</em> system are of the form
<code class="docutils literal notranslate"><span class="pre">&lt;prefix&gt;-&lt;node</span> <span class="pre">id&gt;-&lt;device</span> <span class="pre">id&gt;.tr</span></code></p>
<p>As previously mentioned, every Node in the system will have a
system-assigned Node id; and every device will have an interface index
(also called a device id) relative to its node.  By default, then, an
ASCII trace file created as a result of enabling tracing on the first
device of Node 21, using the prefix “prefix”, would be
<code class="docutils literal notranslate"><span class="pre">prefix-21-1.tr</span></code>.</p>
<p>You can always use the <em>ns-3</em> object name service to make this more
clear.  For example, if you use the object name service to assign the
name “server” to Node 21, the resulting ASCII trace file name will
automatically become, <code class="docutils literal notranslate"><span class="pre">prefix-server-1.tr</span></code> and if you also assign the
name “eth0” to the device, your ASCII trace file name will
automatically pick this up and be called <code class="docutils literal notranslate"><span class="pre">prefix-server-eth0.tr</span></code>.</p>
<p>Several of the methods have a default parameter called
<code class="docutils literal notranslate"><span class="pre">explicitFilename</span></code>.  When set to true, this parameter disables the
automatic filename completion mechanism and allows you to create an
explicit filename.  This option is only available in the methods which
take a prefix and enable tracing on a single device.</p>
</section>
</section>
</section>
<section id="protocol-helpers">
<h3><span class="section-number">8.4.2. </span>Protocol Helpers<a class="headerlink" href="#protocol-helpers" title="Link to this heading">¶</a></h3>
<section id="id4">
<h4><span class="section-number">8.4.2.1. </span>PCAP<a class="headerlink" href="#id4" title="Link to this heading">¶</a></h4>
<p>The goal of these <code class="docutils literal notranslate"><span class="pre">mixins</span></code> is to make it easy to add a consistent
PCAP trace facility to protocols.  We want all of the various flavors
of PCAP tracing to work the same across all protocols, so the methods
of these helpers are inherited by stack helpers.  Take a look at
<code class="docutils literal notranslate"><span class="pre">src/network/helper/trace-helper.h</span></code> if you want to follow the
discussion while looking at real code.</p>
<p>In this section we will be illustrating the methods as applied to the
protocol <code class="docutils literal notranslate"><span class="pre">Ipv4</span></code>.  To specify traces in similar protocols, just
substitute the appropriate type.  For example, use a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Ipv6&gt;</span></code>
instead of a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Ipv4&gt;</span></code> and call <code class="docutils literal notranslate"><span class="pre">EnablePcapIpv6</span></code> instead of
<code class="docutils literal notranslate"><span class="pre">EnablePcapIpv4</span></code>.</p>
<p>The class <code class="docutils literal notranslate"><span class="pre">PcapHelperForIpv4</span></code> provides the high level functionality
for using PCAP tracing in the <code class="docutils literal notranslate"><span class="pre">Ipv4</span></code> protocol.  Each protocol helper
enabling these methods must implement a single virtual method
inherited from this class.  There will be a separate implementation
for <code class="docutils literal notranslate"><span class="pre">Ipv6</span></code>, for example, but the only difference will be in the
method names and signatures.  Different method names are required to
disambiguate class <code class="docutils literal notranslate"><span class="pre">Ipv4</span></code> from <code class="docutils literal notranslate"><span class="pre">Ipv6</span></code> which are both derived from
class <code class="docutils literal notranslate"><span class="pre">Object</span></code>, and methods that share the same signature.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcapIpv4Internal</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4</span><span class="p">,</span>
<span class="w">                                    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">,</span>
<span class="w">                                    </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>The signature of this method reflects the protocol and
interface-centric view of the situation at this level.  All of the
public methods inherited from class <code class="docutils literal notranslate"><span class="pre">PcapHelperForIpv4</span></code> reduce to
calling this single device-dependent implementation method.  For
example, the lowest level PCAP method,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcapIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
</pre></div>
</div>
<p>will call the device implementation of <code class="docutils literal notranslate"><span class="pre">EnablePcapIpv4Internal</span></code>
directly.  All other public PCAP tracing methods build on this
implementation to provide additional user-level functionality.  What
this means to the user is that all protocol helpers in the system will
have all of the PCAP trace methods available; and these methods will
all work in the same way across protocols if the helper implements
<code class="docutils literal notranslate"><span class="pre">EnablePcapIpv4Internal</span></code> correctly.</p>
<section id="id5">
<h5><span class="section-number">8.4.2.1.1. </span>Methods<a class="headerlink" href="#id5" title="Link to this heading">¶</a></h5>
<p>These methods are designed to be in one-to-one correspondence with the
Node- and <code class="docutils literal notranslate"><span class="pre">NetDevice</span></code>- centric versions of the device versions.
Instead of Node and <code class="docutils literal notranslate"><span class="pre">NetDevice</span></code> pair constraints, we use
protocol and interface constraints.</p>
<p>Note that just like in the device version, there are six methods:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcapIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcapIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">ipv4Name</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcapIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ipv4InterfaceContainer</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcapIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcapIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">nodeid</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcapIpv4All</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">);</span>
</pre></div>
</div>
<p>You are encouraged to peruse the API Documentation for class
<code class="docutils literal notranslate"><span class="pre">PcapHelperForIpv4</span></code> to find the details of these methods; but to
summarize …</p>
<ul>
<li><p>You can enable PCAP tracing on a particular protocol/interface pair by
providing a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Ipv4&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">interface</span></code> to an <code class="docutils literal notranslate"><span class="pre">EnablePcap</span></code>
method.  For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnablePcapIpv4</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ipv4</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>You can enable PCAP tracing on a particular node/net-device pair by
providing a <code class="docutils literal notranslate"><span class="pre">std::string</span></code> representing an object name service string
to an <code class="docutils literal notranslate"><span class="pre">EnablePcap</span></code> method.  The <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Ipv4&gt;</span></code> is looked up from the
name string.  For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;serverIPv4&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnablePcapIpv4</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;serverIpv4&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>You can enable PCAP tracing on a collection of protocol/interface
pairs by providing an <code class="docutils literal notranslate"><span class="pre">Ipv4InterfaceContainer</span></code>.  For each <code class="docutils literal notranslate"><span class="pre">Ipv4</span></code> /
interface pair in the container the protocol type is checked.  For
each protocol of the proper type (the same type as is managed by the
device helper), tracing is enabled for the corresponding interface.
For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">nodes</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">devices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">deviceHelper</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">nodes</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">Ipv4AddressHelper</span><span class="w"> </span><span class="n">ipv4</span><span class="p">;</span>
<span class="n">ipv4</span><span class="p">.</span><span class="n">SetBase</span><span class="p">(</span><span class="s">&quot;10.1.1.0&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;255.255.255.0&quot;</span><span class="p">);</span>
<span class="n">Ipv4InterfaceContainer</span><span class="w"> </span><span class="n">interfaces</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ipv4</span><span class="p">.</span><span class="n">Assign</span><span class="p">(</span><span class="n">devices</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnablePcapIpv4</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">interfaces</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>You can enable PCAP tracing on a collection of protocol/interface
pairs by providing a <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code>.  For each Node in the
<code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code> the appropriate protocol is found.  For each
protocol, its interfaces are enumerated and tracing is enabled on the
resulting pairs.  For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnablePcapIpv4</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>You can enable PCAP tracing on the basis of Node ID and interface as
well.  In this case, the node-id is translated to a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Node&gt;</span></code> and
the appropriate protocol is looked up in the node.  The resulting
protocol and interface are used to specify the resulting trace source.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">helper</span><span class="p">.</span><span class="n">EnablePcapIpv4</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>Finally, you can enable PCAP tracing for all interfaces in the
system, with associated protocol being the same type as that managed
by the device helper.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">helper</span><span class="p">.</span><span class="n">EnablePcapIpv4All</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="id6">
<h5><span class="section-number">8.4.2.1.2. </span>Filenames<a class="headerlink" href="#id6" title="Link to this heading">¶</a></h5>
<p>Implicit in all of the method descriptions above is the construction
of the complete filenames by the implementation method.  By
convention, PCAP traces taken for devices in the <em>ns-3</em> system are of
the form “&lt;prefix&gt;-&lt;node id&gt;-&lt;device id&gt;.pcap”.  In the case of
protocol traces, there is a one-to-one correspondence between
protocols and <code class="docutils literal notranslate"><span class="pre">Nodes</span></code>.  This is because protocol <code class="docutils literal notranslate"><span class="pre">Objects</span></code> are
aggregated to <code class="docutils literal notranslate"><span class="pre">Node</span> <span class="pre">Objects</span></code>.  Since there is no global protocol id
in the system, we use the corresponding Node id in file naming.
Therefore there is a possibility for file name collisions in
automatically chosen trace file names.  For this reason, the file name
convention is changed for protocol traces.</p>
<p>As previously mentioned, every Node in the system will have a
system-assigned Node id.  Since there is a one-to-one correspondence
between protocol instances and Node instances we use the Node id.
Each interface has an interface id relative to its protocol.  We use
the convention “&lt;prefix&gt;-n&lt;node id&gt;-i&lt;interface id&gt;.pcap” for trace
file naming in protocol helpers.</p>
<p>Therefore, by default, a PCAP trace file created as a result of
enabling tracing on interface 1 of the Ipv4 protocol of Node 21 using
the prefix “prefix” would be “prefix-n21-i1.pcap”.</p>
<p>You can always use the <em>ns-3</em> object name service to make this more
clear.  For example, if you use the object name service to assign the
name “serverIpv4” to the Ptr&lt;Ipv4&gt; on Node 21, the resulting PCAP
trace file name will automatically become,
“prefix-nserverIpv4-i1.pcap”.</p>
<p>Several of the methods have a default parameter called
<code class="docutils literal notranslate"><span class="pre">explicitFilename</span></code>.  When set to true, this parameter disables the
automatic filename completion mechanism and allows you to create an
explicit filename.  This option is only available in the methods which
take a prefix and enable tracing on a single device.</p>
</section>
</section>
<section id="id7">
<h4><span class="section-number">8.4.2.2. </span>ASCII<a class="headerlink" href="#id7" title="Link to this heading">¶</a></h4>
<p>The behavior of the ASCII trace helpers is substantially similar to
the PCAP case.  Take a look at <code class="docutils literal notranslate"><span class="pre">src/network/helper/trace-helper.h</span></code>
if you want to follow the discussion while looking at real code.</p>
<p>In this section we will be illustrating the methods as applied to the
protocol <code class="docutils literal notranslate"><span class="pre">Ipv4</span></code>.  To specify traces in similar protocols, just
substitute the appropriate type.  For example, use a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Ipv6&gt;</span></code>
instead of a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Ipv4&gt;</span></code> and call <code class="docutils literal notranslate"><span class="pre">EnableAsciiIpv6</span></code> instead of
<code class="docutils literal notranslate"><span class="pre">EnableAsciiIpv4</span></code>.</p>
<p>The class <code class="docutils literal notranslate"><span class="pre">AsciiTraceHelperForIpv4</span></code> adds the high level
functionality for using ASCII tracing to a protocol helper.  Each
protocol that enables these methods must implement a single virtual
method inherited from this class.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4Internal</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4</span><span class="p">,</span>
<span class="w">                                     </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">,</span>
<span class="w">                                     </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>The signature of this method reflects the protocol- and
interface-centric view of the situation at this level; and also the
fact that the helper may be writing to a shared output stream.  All of
the public methods inherited from class
<code class="docutils literal notranslate"><span class="pre">PcapAndAsciiTraceHelperForIpv4</span></code> reduce to calling this single
device- dependent implementation method.  For example, the lowest
level ASCII trace methods,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">);</span>
</pre></div>
</div>
<p>will call the device implementation of <code class="docutils literal notranslate"><span class="pre">EnableAsciiIpv4Internal</span></code>
directly, providing either the prefix or the stream.  All other public
ASCII tracing methods will build on these low-level functions to
provide additional user-level functionality.  What this means to the
user is that all device helpers in the system will have all of the
ASCII trace methods available; and these methods will all work in the
same way across protocols if the protocols implement
<code class="docutils literal notranslate"><span class="pre">EnableAsciiIpv4Internal</span></code> correctly.</p>
<section id="id8">
<h5><span class="section-number">8.4.2.2.1. </span>Methods<a class="headerlink" href="#id8" title="Link to this heading">¶</a></h5>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">ipv4Name</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">ipv4Name</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ipv4InterfaceContainer</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">Ipv4InterfaceContainer</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4All</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4All</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">nodeid</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">deviceid</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">nodeid</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">);</span>
</pre></div>
</div>
<p>You are encouraged to peruse the API Documentation for class
<code class="docutils literal notranslate"><span class="pre">PcapAndAsciiHelperForIpv4</span></code> to find the details of these methods;
but to summarize …</p>
<ul>
<li><p>There are twice as many methods available for ASCII tracing as there
were for PCAP tracing.  This is because, in addition to the PCAP-style
model where traces from each unique protocol/interface pair are
written to a unique file, we support a model in which trace
information for many protocol/interface pairs is written to a common
file.  This means that the &lt;prefix&gt;-n&lt;node id&gt;-&lt;interface&gt; file name
generation mechanism is replaced by a mechanism to refer to a common
file; and the number of API methods is doubled to allow all
combinations.</p></li>
<li><p>Just as in PCAP tracing, you can enable ASCII tracing on a particular
protocol/interface pair by providing a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Ipv4&gt;</span></code> and an
<code class="docutils literal notranslate"><span class="pre">interface</span></code> to an <code class="docutils literal notranslate"><span class="pre">EnableAscii</span></code> method.  For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ipv4</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>In this case, no trace contexts are written to the ASCII trace file
since they would be redundant.  The system will pick the file name to
be created using the same rules as described in the PCAP section,
except that the file will have the suffix “.tr” instead of “.pcap”.</p>
</li>
<li><p>If you want to enable ASCII tracing on more than one interface and
have all traces sent to a single file, you can do that as well by
using an object to refer to a single file.  We have already something
similar to this in the “cwnd” example above:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">protocol1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">protocol2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">...</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">asciiTraceHelper</span><span class="p">.</span><span class="n">CreateFileStream</span><span class="p">(</span><span class="s">&quot;trace-file-name.tr&quot;</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">protocol1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">protocol2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>In this case, trace contexts are written to the ASCII trace file since
they are required to disambiguate traces from the two interfaces.
Note that since the user is completely specifying the file name, the
string should include the “,tr” for consistency.</p>
</li>
<li><p>You can enable ASCII tracing on a particular protocol by providing a
<code class="docutils literal notranslate"><span class="pre">std::string</span></code> representing an object name service string to an
<code class="docutils literal notranslate"><span class="pre">EnablePcap</span></code> method.  The <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Ipv4&gt;</span></code> is looked up from the name
string.  The <code class="docutils literal notranslate"><span class="pre">&lt;Node&gt;</span></code> in the resulting filenames is implicit since
there is a one-to-one correspondence between protocol instances and
nodes, For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;node1Ipv4&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;node2Ipv4&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;node1Ipv4&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;node2Ipv4&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>This would result in two files named “prefix-nnode1Ipv4-i1.tr” and
“prefix-nnode2Ipv4-i1.tr” with traces for each interface in the
respective trace file.  Since all of the EnableAscii functions are
overloaded to take a stream wrapper, you can use that form as well:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;node1Ipv4&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;node2Ipv4&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="p">...</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">asciiTraceHelper</span><span class="p">.</span><span class="n">CreateFileStream</span><span class="p">(</span><span class="s">&quot;trace-file-name.tr&quot;</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;node1Ipv4&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;node2Ipv4&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>This would result in a single trace file called “trace-file-name.tr”
that contains all of the trace events for both interfaces.  The events
would be disambiguated by trace context strings.</p>
</li>
<li><p>You can enable ASCII tracing on a collection of protocol/interface
pairs by providing an <code class="docutils literal notranslate"><span class="pre">Ipv4InterfaceContainer</span></code>.  For each protocol
of the proper type (the same type as is managed by the device helper),
tracing is enabled for the corresponding interface.  Again, the
<code class="docutils literal notranslate"><span class="pre">&lt;Node&gt;</span></code> is implicit since there is a one-to-one correspondence
between each protocol and its node.  For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">nodes</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">devices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">deviceHelper</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">nodes</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">Ipv4AddressHelper</span><span class="w"> </span><span class="n">ipv4</span><span class="p">;</span>
<span class="n">ipv4</span><span class="p">.</span><span class="n">SetBase</span><span class="p">(</span><span class="s">&quot;10.1.1.0&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;255.255.255.0&quot;</span><span class="p">);</span>
<span class="n">Ipv4InterfaceContainer</span><span class="w"> </span><span class="n">interfaces</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ipv4</span><span class="p">.</span><span class="n">Assign</span><span class="p">(</span><span class="n">devices</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">interfaces</span><span class="p">);</span>
</pre></div>
</div>
<p>This would result in a number of ASCII trace files being created, each
of which follows the &lt;prefix&gt;-n&lt;node id&gt;-i&lt;interface&gt;.tr convention.
Combining all of the traces into a single file is accomplished
similarly to the examples above:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">nodes</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">devices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">deviceHelper</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">nodes</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">Ipv4AddressHelper</span><span class="w"> </span><span class="n">ipv4</span><span class="p">;</span>
<span class="n">ipv4</span><span class="p">.</span><span class="n">SetBase</span><span class="p">(</span><span class="s">&quot;10.1.1.0&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;255.255.255.0&quot;</span><span class="p">);</span>
<span class="n">Ipv4InterfaceContainer</span><span class="w"> </span><span class="n">interfaces</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ipv4</span><span class="p">.</span><span class="n">Assign</span><span class="p">(</span><span class="n">devices</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">asciiTraceHelper</span><span class="p">.</span><span class="n">CreateFileStream</span><span class="p">(</span><span class="s">&quot;trace-file-name.tr&quot;</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">interfaces</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>You can enable ASCII tracing on a collection of protocol/interface
pairs by providing a <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code>.  For each Node in the
<code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code> the appropriate protocol is found.  For each
protocol, its interfaces are enumerated and tracing is enabled on the
resulting pairs.  For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
<p>This would result in a number of ASCII trace files being created,
each of which follows the &lt;prefix&gt;-&lt;node id&gt;-&lt;device id&gt;.tr
convention.  Combining all of the traces into a single file is
accomplished similarly to the examples above.</p>
</li>
<li><p>You can enable ASCII tracing on the basis of Node ID and device ID as
well.  In this case, the node-id is translated to a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Node&gt;</span></code> and
the appropriate protocol is looked up in the node.  The resulting
protocol and interface are used to specify the resulting trace source.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>Of course, the traces can be combined into a single file as shown
above.</p>
</li>
<li><p>Finally, you can enable ASCII tracing for all interfaces in the
system, with associated protocol being the same type as that managed
by the device helper.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4All</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>This would result in a number of ASCII trace files being created, one
for every interface in the system related to a protocol of the type
managed by the helper.  All of these files will follow the
&lt;prefix&gt;-n&lt;node id&gt;-i&lt;interface.tr convention.  Combining all of the
traces into a single file is accomplished similarly to the examples
above.</p>
</li>
</ul>
</section>
<section id="id9">
<h5><span class="section-number">8.4.2.2.2. </span>Filenames<a class="headerlink" href="#id9" title="Link to this heading">¶</a></h5>
<p>Implicit in the prefix-style method descriptions above is the
construction of the complete filenames by the implementation method.
By convention, ASCII traces in the <em>ns-3</em> system are of the form
“&lt;prefix&gt;-&lt;node id&gt;-&lt;device id&gt;.tr”</p>
<p>As previously mentioned, every Node in the system will have a
system-assigned Node id.  Since there is a one-to-one correspondence
between protocols and nodes we use to node-id to identify the protocol
identity.  Every interface on a given protocol will have an interface
index (also called simply an interface) relative to its protocol.  By
default, then, an ASCII trace file created as a result of enabling
tracing on the first device of Node 21, using the prefix “prefix”,
would be “prefix-n21-i1.tr”.  Use the prefix to disambiguate multiple
protocols per node.</p>
<p>You can always use the <em>ns-3</em> object name service to make this more
clear.  For example, if you use the object name service to assign the
name “serverIpv4” to the protocol on Node 21, and also specify
interface one, the resulting ASCII trace file name will automatically
become, “prefix-nserverIpv4-1.tr”.</p>
<p>Several of the methods have a default parameter called
<code class="docutils literal notranslate"><span class="pre">explicitFilename</span></code>.  When set to true, this parameter disables the
automatic filename completion mechanism and allows you to create an
explicit filename.  This option is only available in the methods which
take a prefix and enable tracing on a single device.</p>
</section>
</section>
</section>
</section>
<section id="summary">
<h2><span class="section-number">8.5. </span>Summary<a class="headerlink" href="#summary" title="Link to this heading">¶</a></h2>
<p><em>ns-3</em> includes an extremely rich environment allowing users at several
levels to customize the kinds of information that can be extracted
from simulations.</p>
<p>There are high-level helper functions that allow users to simply
control the collection of pre-defined outputs to a fine granularity.
There are mid-level helper functions to allow more sophisticated users
to customize how information is extracted and saved; and there are
low-level core functions to allow expert users to alter the system to
present new and previously unexported information in a way that will
be immediately accessible to users at higher levels.</p>
<p>This is a very comprehensive system, and we realize that it is a lot
to digest, especially for new users or those not intimately familiar
with C++ and its idioms.  We do consider the tracing system a very
important part of <em>ns-3</em> and so recommend becoming as familiar as
possible with it.  It is probably the case that understanding the rest
of the <em>ns-3</em> system will be quite simple once you have mastered the
tracing system</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">ns-3</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, vishnu.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../_sources/doc/tutorial/source/tracing.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>