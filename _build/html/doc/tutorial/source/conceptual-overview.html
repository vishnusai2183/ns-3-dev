<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>5. Conceptual Overview &#8212; ns-3 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=039e1c02" />
    <script src="../../../_static/documentation_options.js?v=f2a433a1"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="conceptual-overview">
<span id="id1"></span><h1><span class="section-number">5. </span>Conceptual Overview<a class="headerlink" href="#conceptual-overview" title="Link to this heading">¶</a></h1>
<p>The first thing we need to do before actually starting to look at or write
<em>ns-3</em> code is to explain a few core concepts and abstractions in the
system.  Much of this may appear transparently obvious to some, but we
recommend taking the time to read through this section just to ensure you
are starting on a firm foundation.</p>
<section id="key-abstractions">
<h2><span class="section-number">5.1. </span>Key Abstractions<a class="headerlink" href="#key-abstractions" title="Link to this heading">¶</a></h2>
<p>In this section, we’ll review some terms that are commonly used in
networking, but have a specific meaning in <em>ns-3</em>.</p>
<section id="node">
<h3><span class="section-number">5.1.1. </span>Node<a class="headerlink" href="#node" title="Link to this heading">¶</a></h3>
<p>In Internet jargon, a computing device that connects to a network is called
a <em>host</em> or sometimes an <em>end system</em>.  Because <em>ns-3</em> is a
<em>network</em> simulator, not specifically an <em>Internet</em> simulator, we
intentionally do not use the term host since it is closely associated with
the Internet and its protocols.  Instead, we use a more generic term also
used by other simulators that originates in Graph Theory — the <em>node</em>.</p>
<p>In <em>ns-3</em> the basic computing device abstraction is called the
node.  This abstraction is represented in C++ by the class <code class="docutils literal notranslate"><span class="pre">Node</span></code>.  The
<code class="docutils literal notranslate"><span class="pre">Node</span></code> class provides methods for managing the representations of
computing devices in simulations.</p>
<p>You should think of a <code class="docutils literal notranslate"><span class="pre">Node</span></code> as a computer to which you will add
functionality.  One adds things like applications, protocol stacks and
peripheral cards with their associated drivers to enable the computer to do
useful work.  We use the same basic model in <em>ns-3</em>.</p>
</section>
<section id="application">
<h3><span class="section-number">5.1.2. </span>Application<a class="headerlink" href="#application" title="Link to this heading">¶</a></h3>
<p>Typically, computer software is divided into two broad classes.  <em>System
Software</em> organizes various computer resources such as memory, processor
cycles, disk, network, etc., according to some computing model.  System
software usually does not use those resources to complete tasks that directly
benefit a user.  A user would typically run an <em>application</em> that acquires
and uses the resources controlled by the system software to accomplish some
goal.</p>
<p>Often, the line of separation between system and application software is made
at the privilege level change that happens in operating system traps.
In <em>ns-3</em> there is no real concept of operating system and especially
no concept of privilege levels or system calls.  We do, however, have the
idea of an application.  Just as software applications run on computers to
perform tasks in the “real world,” <em>ns-3</em> applications run on
<em>ns-3</em> <code class="docutils literal notranslate"><span class="pre">Nodes</span></code> to drive simulations in the simulated world.</p>
<p>In <em>ns-3</em> the basic abstraction for a user program that generates some
activity to be simulated is the application.  This abstraction is represented
in C++ by the class <code class="docutils literal notranslate"><span class="pre">Application</span></code>.  The <code class="docutils literal notranslate"><span class="pre">Application</span></code> class provides
methods for managing the representations of our version of user-level
applications in simulations.  Developers are expected to specialize the
<code class="docutils literal notranslate"><span class="pre">Application</span></code> class in the object-oriented programming sense to create new
applications.  In this tutorial, we will use specializations of class
<code class="docutils literal notranslate"><span class="pre">Application</span></code> called <code class="docutils literal notranslate"><span class="pre">UdpEchoClientApplication</span></code> and
<code class="docutils literal notranslate"><span class="pre">UdpEchoServerApplication</span></code>.  As you might expect, these applications
compose a client/server application set used to generate and echo simulated
network packets</p>
</section>
<section id="channel">
<h3><span class="section-number">5.1.3. </span>Channel<a class="headerlink" href="#channel" title="Link to this heading">¶</a></h3>
<p>In the real world, one can connect a computer to a network.  Often the media
over which data flows in these networks are called <em>channels</em>.  When
you connect your Ethernet cable to the plug in the wall, you are connecting
your computer to an Ethernet communication channel.  In the simulated world
of <em>ns-3</em>, one connects a <code class="docutils literal notranslate"><span class="pre">Node</span></code> to an object representing a
communication channel.  Here the basic communication subnetwork abstraction
is called the channel and is represented in C++ by the class <code class="docutils literal notranslate"><span class="pre">Channel</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Channel</span></code> class provides methods for managing communication
subnetwork objects and connecting nodes to them.  <code class="docutils literal notranslate"><span class="pre">Channels</span></code> may also be
specialized by developers in the object oriented programming sense.  A
<code class="docutils literal notranslate"><span class="pre">Channel</span></code> specialization may model something as simple as a wire.  The
specialized  <code class="docutils literal notranslate"><span class="pre">Channel</span></code> can also model things as complicated as a large
Ethernet switch, or three-dimensional space full of obstructions in the case
of wireless networks.</p>
<p>We will use specialized versions of the <code class="docutils literal notranslate"><span class="pre">Channel</span></code> called
<code class="docutils literal notranslate"><span class="pre">CsmaChannel</span></code>, <code class="docutils literal notranslate"><span class="pre">PointToPointChannel</span></code> and <code class="docutils literal notranslate"><span class="pre">WifiChannel</span></code> in this
tutorial.  The <code class="docutils literal notranslate"><span class="pre">CsmaChannel</span></code>, for example, models a version of a
communication subnetwork that implements a <em>carrier sense multiple
access</em> communication medium.  This gives us Ethernet-like functionality.</p>
</section>
<section id="net-device">
<h3><span class="section-number">5.1.4. </span>Net Device<a class="headerlink" href="#net-device" title="Link to this heading">¶</a></h3>
<p>It used to be the case that if you wanted to connect a computer to a network,
you had to buy a specific kind of network cable and a hardware device called
(in PC terminology) a <em>peripheral card</em> that needed to be installed in
your computer.  If the peripheral card implemented some networking function,
they were called Network Interface Cards, or <em>NICs</em>.  Today most
computers come with the network interface hardware built in and users don’t
see these building blocks.</p>
<p>A NIC will not work without a software driver to control the hardware.  In
Unix (or Linux), a piece of peripheral hardware is classified as a
<em>device</em>.  Devices are controlled using <em>device drivers</em>, and network
devices (NICs) are controlled using <em>network device drivers</em>
collectively known as <em>net devices</em>.  In Unix and Linux you refer
to these net devices by names such as <em>eth0</em>.</p>
<p>In <em>ns-3</em> the <em>net device</em> abstraction covers both the software
driver and the simulated hardware.  A net device is “installed” in a
<code class="docutils literal notranslate"><span class="pre">Node</span></code> in order to enable the <code class="docutils literal notranslate"><span class="pre">Node</span></code> to communicate with other
<code class="docutils literal notranslate"><span class="pre">Nodes</span></code> in the simulation via <code class="docutils literal notranslate"><span class="pre">Channels</span></code>.  Just as in a real
computer, a <code class="docutils literal notranslate"><span class="pre">Node</span></code> may be connected to more than one <code class="docutils literal notranslate"><span class="pre">Channel</span></code> via
multiple <code class="docutils literal notranslate"><span class="pre">NetDevices</span></code>.</p>
<p>The net device abstraction is represented in C++ by the class <code class="docutils literal notranslate"><span class="pre">NetDevice</span></code>.
The <code class="docutils literal notranslate"><span class="pre">NetDevice</span></code> class provides methods for managing connections to
<code class="docutils literal notranslate"><span class="pre">Node</span></code> and <code class="docutils literal notranslate"><span class="pre">Channel</span></code> objects; and may be specialized by developers
in the object-oriented programming sense.  We will use the several specialized
versions of the <code class="docutils literal notranslate"><span class="pre">NetDevice</span></code> called <code class="docutils literal notranslate"><span class="pre">CsmaNetDevice</span></code>,
<code class="docutils literal notranslate"><span class="pre">PointToPointNetDevice</span></code>, and <code class="docutils literal notranslate"><span class="pre">WifiNetDevice</span></code> in this tutorial.
Just as an Ethernet NIC is designed to work with an Ethernet network, the
<code class="docutils literal notranslate"><span class="pre">CsmaNetDevice</span></code> is designed to work with a <code class="docutils literal notranslate"><span class="pre">CsmaChannel</span></code>; the
<code class="docutils literal notranslate"><span class="pre">PointToPointNetDevice</span></code> is designed to work with a
<code class="docutils literal notranslate"><span class="pre">PointToPointChannel</span></code> and a <code class="docutils literal notranslate"><span class="pre">WifiNetDevice</span></code> is designed to work with
a <code class="docutils literal notranslate"><span class="pre">WifiChannel</span></code>.</p>
</section>
<section id="topology-helpers">
<h3><span class="section-number">5.1.5. </span>Topology Helpers<a class="headerlink" href="#topology-helpers" title="Link to this heading">¶</a></h3>
<p>In a real network, you will find host computers with added (or built-in)
NICs.  In <em>ns-3</em> we would say that you will find <code class="docutils literal notranslate"><span class="pre">Nodes</span></code> with
attached <code class="docutils literal notranslate"><span class="pre">NetDevices</span></code>.  In a large simulated network you will need to
arrange many connections between <code class="docutils literal notranslate"><span class="pre">Nodes</span></code>, <code class="docutils literal notranslate"><span class="pre">NetDevices</span></code> and
<code class="docutils literal notranslate"><span class="pre">Channels</span></code>.</p>
<p>Since connecting <code class="docutils literal notranslate"><span class="pre">NetDevices</span></code> to <code class="docutils literal notranslate"><span class="pre">Nodes</span></code>, <code class="docutils literal notranslate"><span class="pre">NetDevices</span></code>
to <code class="docutils literal notranslate"><span class="pre">Channels</span></code>, assigning IP addresses,  etc., are such common tasks
in <em>ns-3</em>, we provide what we call <em>topology helpers</em> to make
this as easy as possible.  For example, it may take many distinct
<em>ns-3</em> core operations to create a NetDevice, add a MAC address,
install that net device on a <code class="docutils literal notranslate"><span class="pre">Node</span></code>, configure the node’s protocol stack,
and then connect the <code class="docutils literal notranslate"><span class="pre">NetDevice</span></code> to a <code class="docutils literal notranslate"><span class="pre">Channel</span></code>.  Even more
operations would be required to connect multiple devices onto multipoint
channels and then to connect individual networks together into internetworks.
We provide topology helper objects that combine those many distinct operations
into an easy to use model for your convenience.</p>
</section>
</section>
<section id="a-first-ns-3-script">
<h2><span class="section-number">5.2. </span>A First ns-3 Script<a class="headerlink" href="#a-first-ns-3-script" title="Link to this heading">¶</a></h2>
<p>If you downloaded the system as was suggested above, you will have a release
of <em>ns-3</em> in a directory called <code class="docutils literal notranslate"><span class="pre">workspace</span></code> under your home
directory.  Change into that release directory, and you should find a
directory structure something like the following:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>AUTHORS<span class="w">        </span>CMakeLists.txt<span class="w">   </span>examples<span class="w">   </span>RELEASE_NOTES.md<span class="w">  </span>testpy.supp
bindings<span class="w">       </span>contrib<span class="w">          </span>LICENSE<span class="w">    </span>scratch<span class="w">           </span>utils
build-support<span class="w">  </span>CONTRIBUTING.md<span class="w">  </span>ns3<span class="w">        </span>src<span class="w">               </span>utils.py
CHANGES.md<span class="w">     </span>doc<span class="w">              </span>README.md<span class="w">  </span>test.py<span class="w">           </span>VERSION
</pre></div>
</div>
<p>Change into the <code class="docutils literal notranslate"><span class="pre">examples/tutorial</span></code> directory.  You should see a file named
<code class="docutils literal notranslate"><span class="pre">first.cc</span></code> located there.  This is a script that will create a simple
point-to-point link between two nodes and echo a single packet between the
nodes.  Let’s take a look at that script line by line, so go ahead and open
<code class="docutils literal notranslate"><span class="pre">first.cc</span></code> in your favorite editor.</p>
<section id="copyright">
<h3><span class="section-number">5.2.1. </span>Copyright<a class="headerlink" href="#copyright" title="Link to this heading">¶</a></h3>
<p>The <em>ns-3</em> simulator is licensed using the GNU General Public
License version 2.  You will see the appropriate GNU legalese at the head of every file
in the <em>ns-3</em> distribution.  Often you will see a copyright notice for
one of the institutions involved in the <em>ns-3</em> project above the GPL
text and an author listed below.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> */</span>
</pre></div>
</div>
</section>
<section id="module-includes">
<h3><span class="section-number">5.2.2. </span>Module Includes<a class="headerlink" href="#module-includes" title="Link to this heading">¶</a></h3>
<p>The code proper starts with a number of include statements.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ns3/core-module.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ns3/network-module.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ns3/internet-module.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ns3/point-to-point-module.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ns3/applications-module.h&quot;</span>
</pre></div>
</div>
<p>To help our high-level script users deal with the large number of include
files present in the system, we group includes according to relatively large
modules.  We provide a single include file that will recursively load all of
the include files used in each module.  Rather than having to look up exactly
what header you need, and possibly have to get a number of dependencies right,
we give you the ability to load a group of files at a large granularity.  This
is not the most efficient approach but it certainly makes writing scripts much
easier.</p>
<p>Each of the <em>ns-3</em> include files is placed in a directory called
<code class="docutils literal notranslate"><span class="pre">ns3</span></code> (under the build directory) during the build process to help avoid
include file name collisions.  The <code class="docutils literal notranslate"><span class="pre">ns3/core-module.h</span></code> file corresponds
to the ns-3 module you will find in the directory <code class="docutils literal notranslate"><span class="pre">src/core</span></code> in your
downloaded release distribution.  If you list this directory you will find a
large number of header files.  When you do a build, ns3 will place public
header files in an <code class="docutils literal notranslate"><span class="pre">ns3</span></code> directory under the appropriate
<code class="docutils literal notranslate"><span class="pre">build/debug</span></code> or <code class="docutils literal notranslate"><span class="pre">build/optimized</span></code> directory depending on your
configuration.  CMake will also automatically generate a module include file to
load all of the public header files.</p>
<p>Since you are, of course, following this tutorial religiously, you will
already have run the following command from the top-level directory:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>configure<span class="w"> </span>-d<span class="w"> </span>debug<span class="w"> </span>--enable-examples<span class="w"> </span>--enable-tests
</pre></div>
</div>
<p>in order to configure the project to perform debug builds that include
examples and tests.  You will also have called</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>build
</pre></div>
</div>
<p>to build the project.  So now if you look in the directory
<code class="docutils literal notranslate"><span class="pre">../../build/include/ns3</span></code> you will find the four module include files shown
above (among many other header files).  You can take a look at the contents of these files and find that they
do include all of the public include files in their respective modules.</p>
</section>
<section id="ns3-namespace">
<h3><span class="section-number">5.2.3. </span>Ns3 Namespace<a class="headerlink" href="#ns3-namespace" title="Link to this heading">¶</a></h3>
<p>The next line in the <code class="docutils literal notranslate"><span class="pre">first.cc</span></code> script is a namespace declaration.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ns3</span><span class="p">;</span>
</pre></div>
</div>
<p>The <em>ns-3</em> project is implemented in a C++ namespace called
<code class="docutils literal notranslate"><span class="pre">ns3</span></code>.  This groups all <em>ns-3</em>-related declarations in a scope
outside the global namespace, which we hope will help with integration with
other code.  The C++ <code class="docutils literal notranslate"><span class="pre">using</span></code> statement introduces the <em>ns-3</em>
namespace into the current (global) declarative region.  This is a fancy way
of saying that after this declaration, you will not have to type <code class="docutils literal notranslate"><span class="pre">ns3::</span></code>
scope resolution operator before all of the <em>ns-3</em> code in order to use
it.  If you are unfamiliar with namespaces, please consult almost any C++
tutorial and compare the <code class="docutils literal notranslate"><span class="pre">ns3</span></code> namespace and usage here with instances of
the <code class="docutils literal notranslate"><span class="pre">std</span></code> namespace and the <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span> <span class="pre">std;</span></code> statements you
will often find in discussions of <code class="docutils literal notranslate"><span class="pre">cout</span></code> and streams.</p>
</section>
<section id="logging">
<h3><span class="section-number">5.2.4. </span>Logging<a class="headerlink" href="#logging" title="Link to this heading">¶</a></h3>
<p>The next line of the script is the following,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NS_LOG_COMPONENT_DEFINE</span><span class="p">(</span><span class="s">&quot;FirstScriptExample&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>We will use this statement as a convenient place to talk about our Doxygen
documentation system.  If you look at the project web site,
<a class="reference external" href="https://www.nsnam.org">ns-3 project</a>, you will find a link to “Documentation” in the navigation bar.  If you select this link, you will be
taken to our documentation page. There
is a link to “Latest Release” that will take you to the documentation
for the latest stable release of <em>ns-3</em>.
If you select the “API Documentation” link, you will be
taken to the <em>ns-3</em> API documentation page.</p>
<p>Along the left side, you will find a graphical representation of the structure
of the documentation.  A good place to start is the <code class="docutils literal notranslate"><span class="pre">NS-3</span> <span class="pre">Modules</span></code>
“book” in the <em>ns-3</em> navigation tree.  If you expand <code class="docutils literal notranslate"><span class="pre">Modules</span></code>
you will see a list of <em>ns-3</em> module documentation.  The concept of
module here ties directly into the module include files discussed above.  The <em>ns-3</em> logging subsystem is discussed in the <a class="reference internal" href="tweaking.html#usinglogging"><span class="std std-ref">Using the Logging Module</span></a> section, so
we’ll get to it later in this tutorial, but you can find out about the above
statement by looking at the <code class="docutils literal notranslate"><span class="pre">Core</span></code> module, then expanding the
<code class="docutils literal notranslate"><span class="pre">Debugging</span> <span class="pre">tools</span></code> book, and then selecting the <code class="docutils literal notranslate"><span class="pre">Logging</span></code> page.  Click
on <code class="docutils literal notranslate"><span class="pre">Logging</span></code>.</p>
<p>You should now be looking at the Doxygen documentation for the Logging module.
In the list of <code class="docutils literal notranslate"><span class="pre">Macros</span></code>’s at the top of the page you will see the entry
for <code class="docutils literal notranslate"><span class="pre">NS_LOG_COMPONENT_DEFINE</span></code>.  Before jumping in, it would probably be
good to look for the “Detailed Description” of the logging module to get a
feel for the overall operation.  You can either scroll down or select the
“More…” link under the collaboration diagram to do this.</p>
<p>Once you have a general idea of what is going on, go ahead and take a look at
the specific <code class="docutils literal notranslate"><span class="pre">NS_LOG_COMPONENT_DEFINE</span></code> documentation.  I won’t duplicate
the documentation here, but to summarize, this line declares a logging
component called <code class="docutils literal notranslate"><span class="pre">FirstScriptExample</span></code> that allows you to enable and
disable console message logging by reference to the name.</p>
</section>
<section id="main-function">
<h3><span class="section-number">5.2.5. </span>Main Function<a class="headerlink" href="#main-function" title="Link to this heading">¶</a></h3>
<p>The next lines of the script you will find are,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
</pre></div>
</div>
<p>This is just the declaration of the main function of your program (script).
Just as in any C++ program, you need to define a main function that will be
the first function run.  There is nothing at all special here.  Your
<em>ns-3</em> script is just a C++ program.</p>
<p>The next line sets the time resolution to one nanosecond, which happens
to be the default value:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Time</span><span class="o">::</span><span class="n">SetResolution</span><span class="p">(</span><span class="n">Time</span><span class="o">::</span><span class="n">NS</span><span class="p">);</span>
</pre></div>
</div>
<p>The resolution is the smallest time value that can be represented (as well as
the smallest representable difference between two time values).
You can change the resolution exactly once.  The mechanism enabling this
flexibility is somewhat memory hungry, so once the resolution has been
set explicitly we release the memory, preventing further updates.   (If
you don’t set the resolution explicitly, it will default to one nanosecond,
and the memory will be released when the simulation starts.)</p>
<p>The next two lines of the script are used to enable two logging components that
are built into the Echo Client and Echo Server applications:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">LogComponentEnable</span><span class="p">(</span><span class="s">&quot;UdpEchoClientApplication&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">LOG_LEVEL_INFO</span><span class="p">);</span>
<span class="n">LogComponentEnable</span><span class="p">(</span><span class="s">&quot;UdpEchoServerApplication&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">LOG_LEVEL_INFO</span><span class="p">);</span>
</pre></div>
</div>
<p>If you have read over the Logging component documentation you will have seen
that there are a number of levels of logging verbosity/detail that you can
enable on each component.  These two lines of code enable debug logging at the
INFO level for echo clients and servers.  This will result in the application
printing out messages as packets are sent and received during the simulation.</p>
<p>Now we will get directly to the business of creating a topology and running
a simulation.  We use the topology helper objects to make this job as
easy as possible.</p>
</section>
<section id="id2">
<h3><span class="section-number">5.2.6. </span>Topology Helpers<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h3>
<section id="nodecontainer">
<h4><span class="section-number">5.2.6.1. </span>NodeContainer<a class="headerlink" href="#nodecontainer" title="Link to this heading">¶</a></h4>
<p>The next two lines of code in our script will actually create the
<em>ns-3</em> <code class="docutils literal notranslate"><span class="pre">Node</span></code> objects that will represent the computers in the
simulation.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">nodes</span><span class="p">;</span>
<span class="n">nodes</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>Let’s find the documentation for the <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code> class before we
continue.  Another way to get into the documentation for a given class is via
the <code class="docutils literal notranslate"><span class="pre">Classes</span></code> tab in the Doxygen pages.  If you still have the Doxygen
handy, just scroll up to the top of the page and select the <code class="docutils literal notranslate"><span class="pre">Classes</span></code>
tab.  You should see a new set of tabs appear, one of which is
<code class="docutils literal notranslate"><span class="pre">Class</span> <span class="pre">List</span></code>.  Under that tab you will see a list of all of the
<em>ns-3</em> classes.  Scroll down, looking for <code class="docutils literal notranslate"><span class="pre">ns3::NodeContainer</span></code>.
When you find the class, go ahead and select it to go to the documentation for
the class.</p>
<p>You may recall that one of our key abstractions is the <code class="docutils literal notranslate"><span class="pre">Node</span></code>.  This
represents a computer to which we are going to add things like protocol stacks,
applications and peripheral cards.  The <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code> topology helper
provides a convenient way to create, manage and access any <code class="docutils literal notranslate"><span class="pre">Node</span></code> objects
that we create in order to run a simulation.  The first line above just
declares a NodeContainer which we call <code class="docutils literal notranslate"><span class="pre">nodes</span></code>.  The second line calls the
<code class="docutils literal notranslate"><span class="pre">Create</span></code> method on the <code class="docutils literal notranslate"><span class="pre">nodes</span></code> object and asks the container to
create two nodes.  As described in the Doxygen, the container calls down into
the <em>ns-3</em> system proper to create two <code class="docutils literal notranslate"><span class="pre">Node</span></code> objects and stores
pointers to those objects internally.</p>
<p>The nodes as they stand in the script do nothing.  The next step in
constructing a topology is to connect our nodes together into a network.
The simplest form of network we support is a single point-to-point link
between two nodes.  We’ll construct one of those links here.</p>
</section>
<section id="pointtopointhelper">
<h4><span class="section-number">5.2.6.2. </span>PointToPointHelper<a class="headerlink" href="#pointtopointhelper" title="Link to this heading">¶</a></h4>
<p>We are constructing a point to point link, and, in a pattern which will become
quite familiar to you, we use a topology helper object to do the low-level
work required to put the link together.  Recall that two of our key
abstractions are the <code class="docutils literal notranslate"><span class="pre">NetDevice</span></code> and the <code class="docutils literal notranslate"><span class="pre">Channel</span></code>.  In the real
world, these terms correspond roughly to peripheral cards and network cables.
Typically these two things are intimately tied together and one cannot expect
to interchange, for example, Ethernet devices and wireless channels.  Our
Topology Helpers follow this intimate coupling and therefore you will use a
single <code class="docutils literal notranslate"><span class="pre">PointToPointHelper</span></code> to configure and connect <em>ns-3</em>
<code class="docutils literal notranslate"><span class="pre">PointToPointNetDevice</span></code> and <code class="docutils literal notranslate"><span class="pre">PointToPointChannel</span></code> objects in this
script.</p>
<p>The next three lines in the script are,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">PointToPointHelper</span><span class="w"> </span><span class="n">pointToPoint</span><span class="p">;</span>
<span class="n">pointToPoint</span><span class="p">.</span><span class="n">SetDeviceAttribute</span><span class="p">(</span><span class="s">&quot;DataRate&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;5Mbps&quot;</span><span class="p">));</span>
<span class="n">pointToPoint</span><span class="p">.</span><span class="n">SetChannelAttribute</span><span class="p">(</span><span class="s">&quot;Delay&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;2ms&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>The first line,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">PointToPointHelper</span><span class="w"> </span><span class="n">pointToPoint</span><span class="p">;</span>
</pre></div>
</div>
<p>instantiates a <code class="docutils literal notranslate"><span class="pre">PointToPointHelper</span></code> object on the stack.  From a
high-level perspective the next line,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">pointToPoint</span><span class="p">.</span><span class="n">SetDeviceAttribute</span><span class="p">(</span><span class="s">&quot;DataRate&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;5Mbps&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>tells the <code class="docutils literal notranslate"><span class="pre">PointToPointHelper</span></code> object to use the value “5Mbps”
(five megabits per second) as the “DataRate” when it creates a
<code class="docutils literal notranslate"><span class="pre">PointToPointNetDevice</span></code> object.</p>
<p>From a more detailed perspective, the string “DataRate” corresponds
to what we call an <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> of the <code class="docutils literal notranslate"><span class="pre">PointToPointNetDevice</span></code>.
If you look at the Doxygen for class <code class="docutils literal notranslate"><span class="pre">ns3::PointToPointNetDevice</span></code> and
find the documentation for the <code class="docutils literal notranslate"><span class="pre">GetTypeId</span></code> method, you will find a list
of  <code class="docutils literal notranslate"><span class="pre">Attributes</span></code> defined for the device.  Among these is the “DataRate”
<code class="docutils literal notranslate"><span class="pre">Attribute</span></code>.  Most user-visible <em>ns-3</em> objects have similar lists of
<code class="docutils literal notranslate"><span class="pre">Attributes</span></code>.  We use this mechanism to easily configure simulations without
recompiling as you will see in a following section.</p>
<p>Similar to the “DataRate” on the <code class="docutils literal notranslate"><span class="pre">PointToPointNetDevice</span></code> you will find a
“Delay” <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> associated with the <code class="docutils literal notranslate"><span class="pre">PointToPointChannel</span></code>.  The
final line,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">pointToPoint</span><span class="p">.</span><span class="n">SetChannelAttribute</span><span class="p">(</span><span class="s">&quot;Delay&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;2ms&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>tells the <code class="docutils literal notranslate"><span class="pre">PointToPointHelper</span></code> to use the value “2ms” (two milliseconds)
as the value of the propagation delay of every point to point channel it
subsequently creates.</p>
</section>
<section id="netdevicecontainer">
<h4><span class="section-number">5.2.6.3. </span>NetDeviceContainer<a class="headerlink" href="#netdevicecontainer" title="Link to this heading">¶</a></h4>
<p>At this point in the script, we have a <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code> that contains
two nodes.  We have a <code class="docutils literal notranslate"><span class="pre">PointToPointHelper</span></code> that is primed and ready to
make <code class="docutils literal notranslate"><span class="pre">PointToPointNetDevices</span></code> and wire <code class="docutils literal notranslate"><span class="pre">PointToPointChannel</span></code> objects
between them.  Just as we used the <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code> topology helper object
to create the <code class="docutils literal notranslate"><span class="pre">Nodes</span></code> for our simulation, we will ask the
<code class="docutils literal notranslate"><span class="pre">PointToPointHelper</span></code> to do the work involved in creating, configuring and
installing our devices for us.  We will need to have a list of all of the
NetDevice objects that are created, so we use a NetDeviceContainer to hold
them just as we used a NodeContainer to hold the nodes we created.  The
following two lines of code,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">devices</span><span class="p">;</span>
<span class="n">devices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pointToPoint</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">nodes</span><span class="p">);</span>
</pre></div>
</div>
<p>will finish configuring the devices and channel.  The first line declares the
device container mentioned above and the second does the heavy lifting.  The
<code class="docutils literal notranslate"><span class="pre">Install</span></code> method of the <code class="docutils literal notranslate"><span class="pre">PointToPointHelper</span></code> takes a
<code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code> as a parameter.  Internally, a <code class="docutils literal notranslate"><span class="pre">NetDeviceContainer</span></code>
is created.  For each node in the <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code> (there must be exactly
two for a point-to-point link) a <code class="docutils literal notranslate"><span class="pre">PointToPointNetDevice</span></code> is created and
saved in the device container.  A <code class="docutils literal notranslate"><span class="pre">PointToPointChannel</span></code> is created and
the two <code class="docutils literal notranslate"><span class="pre">PointToPointNetDevices</span></code> are attached.  When objects are created
by the <code class="docutils literal notranslate"><span class="pre">PointToPointHelper</span></code>, the <code class="docutils literal notranslate"><span class="pre">Attributes</span></code> previously set in the
helper are used to initialize the corresponding <code class="docutils literal notranslate"><span class="pre">Attributes</span></code> in the
created objects.</p>
<p>After executing the <code class="docutils literal notranslate"><span class="pre">pointToPoint.Install(nodes)</span></code> call we will have
two nodes, each with an installed point-to-point net device and a single
point-to-point channel between them.  Both devices will be configured to
transmit data at five megabits per second over the channel which has a two
millisecond transmission delay.</p>
</section>
<section id="internetstackhelper">
<h4><span class="section-number">5.2.6.4. </span>InternetStackHelper<a class="headerlink" href="#internetstackhelper" title="Link to this heading">¶</a></h4>
<p>We now have nodes and devices configured, but we don’t have any protocol stacks
installed on our nodes.  The next two lines of code will take care of that.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">InternetStackHelper</span><span class="w"> </span><span class="n">stack</span><span class="p">;</span>
<span class="n">stack</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">nodes</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">InternetStackHelper</span></code> is a topology helper that is to internet stacks
what the <code class="docutils literal notranslate"><span class="pre">PointToPointHelper</span></code> is to point-to-point net devices.  The
<code class="docutils literal notranslate"><span class="pre">Install</span></code> method takes a <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code> as a parameter.  When it is
executed, it will install an Internet Stack (TCP, UDP, IP, etc.) on each of
the nodes in the node container.</p>
</section>
<section id="ipv4addresshelper">
<h4><span class="section-number">5.2.6.5. </span>Ipv4AddressHelper<a class="headerlink" href="#ipv4addresshelper" title="Link to this heading">¶</a></h4>
<p>Next we need to associate the devices on our nodes with IP addresses.  We
provide a topology helper to manage the allocation of IP addresses.  The only
user-visible API is to set the base IP address and network mask to use when
performing the actual address allocation (which is done at a lower level
inside the helper).</p>
<p>The next two lines of code in our example script, <code class="docutils literal notranslate"><span class="pre">first.cc</span></code>,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ipv4AddressHelper</span><span class="w"> </span><span class="n">address</span><span class="p">;</span>
<span class="n">address</span><span class="p">.</span><span class="n">SetBase</span><span class="p">(</span><span class="s">&quot;10.1.1.0&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;255.255.255.0&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>declare an address helper object and tell it that it should begin allocating IP
addresses from the network 10.1.1.0 using the mask 255.255.255.0 to define
the allocatable bits.  By default the addresses allocated will start at one
and increase monotonically, so the first address allocated from this base will
be 10.1.1.1, followed by 10.1.1.2, etc.  The low level <em>ns-3</em> system
actually remembers all of the IP addresses allocated and will generate a
fatal error if you accidentally cause the same address to be generated twice
(which is a very hard to debug error, by the way).</p>
<p>The next line of code,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ipv4InterfaceContainer</span><span class="w"> </span><span class="n">interfaces</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">Assign</span><span class="p">(</span><span class="n">devices</span><span class="p">);</span>
</pre></div>
</div>
<p>performs the actual address assignment.  In <em>ns-3</em> we make the
association between an IP address and a device using an <code class="docutils literal notranslate"><span class="pre">Ipv4Interface</span></code>
object.  Just as we sometimes need a list of net devices created by a helper
for future reference we sometimes need a list of <code class="docutils literal notranslate"><span class="pre">Ipv4Interface</span></code> objects.
The <code class="docutils literal notranslate"><span class="pre">Ipv4InterfaceContainer</span></code> provides this functionality.</p>
<p>Now we have a point-to-point network built, with stacks installed and IP
addresses assigned.  What we need at this point are applications to generate
traffic.</p>
</section>
</section>
<section id="applications">
<h3><span class="section-number">5.2.7. </span>Applications<a class="headerlink" href="#applications" title="Link to this heading">¶</a></h3>
<p>Another one of the core abstractions of the ns-3 system is the
<code class="docutils literal notranslate"><span class="pre">Application</span></code>.  In this script we use two specializations of the core
<em>ns-3</em> class <code class="docutils literal notranslate"><span class="pre">Application</span></code> called <code class="docutils literal notranslate"><span class="pre">UdpEchoServerApplication</span></code>
and <code class="docutils literal notranslate"><span class="pre">UdpEchoClientApplication</span></code>.  Just as we have in our previous
explanations,  we use helper objects to help configure and manage the
underlying objects.  Here, we use <code class="docutils literal notranslate"><span class="pre">UdpEchoServerHelper</span></code> and
<code class="docutils literal notranslate"><span class="pre">UdpEchoClientHelper</span></code> objects to make our lives easier.</p>
<section id="udpechoserverhelper">
<h4><span class="section-number">5.2.7.1. </span>UdpEchoServerHelper<a class="headerlink" href="#udpechoserverhelper" title="Link to this heading">¶</a></h4>
<p>The following lines of code in our example script, <code class="docutils literal notranslate"><span class="pre">first.cc</span></code>, are used
to set up a UDP echo server application on one of the nodes we have previously
created.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">UdpEchoServerHelper</span><span class="w"> </span><span class="nf">echoServer</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>

<span class="n">ApplicationContainer</span><span class="w"> </span><span class="n">serverApps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">echoServer</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">nodes</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="n">serverApps</span><span class="p">.</span><span class="n">Start</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>
<span class="n">serverApps</span><span class="p">.</span><span class="n">Stop</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">10.0</span><span class="p">));</span>
</pre></div>
</div>
<p>The first line of code in the above snippet declares the
<code class="docutils literal notranslate"><span class="pre">UdpEchoServerHelper</span></code>.  As usual, this isn’t the application itself, it
is an object used to help us create the actual applications.  One of our
conventions is to place <em>required</em> <code class="docutils literal notranslate"><span class="pre">Attributes</span></code> in the helper constructor.
In this case, the helper can’t do anything useful unless it is provided with
a port number that the client also knows about.  Rather than just picking one
and hoping it all works out, we require the port number as a parameter to the
constructor.  The constructor, in turn, simply does a <code class="docutils literal notranslate"><span class="pre">SetAttribute</span></code>
with the passed value.  If you want, you can set the “Port” <code class="docutils literal notranslate"><span class="pre">Attribute</span></code>
to another value later using <code class="docutils literal notranslate"><span class="pre">SetAttribute</span></code>.</p>
<p>Similar to many other helper objects, the <code class="docutils literal notranslate"><span class="pre">UdpEchoServerHelper</span></code> object
has an <code class="docutils literal notranslate"><span class="pre">Install</span></code> method.  It is the execution of this method that actually
causes the underlying echo server application to be instantiated and attached
to a node.  Interestingly, the <code class="docutils literal notranslate"><span class="pre">Install</span></code> method takes a
<code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code> as a parameter just as the other <code class="docutils literal notranslate"><span class="pre">Install</span></code> methods
we have seen.  This is actually what is passed to the method even though it
doesn’t look so in this case.  There is a C++ <em>implicit conversion</em> at
work here that takes the result of <code class="docutils literal notranslate"><span class="pre">nodes.Get(1)</span></code> (which returns a smart
pointer to a node object — <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Node&gt;</span></code>) and uses that in a constructor
for an unnamed <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code> that is then passed to <code class="docutils literal notranslate"><span class="pre">Install</span></code>.
If you are ever at a loss to find a particular method signature in C++ code
that compiles and runs just fine, look for these kinds of implicit conversions.</p>
<p>We now see that <code class="docutils literal notranslate"><span class="pre">echoServer.Install</span></code> is going to install a
<code class="docutils literal notranslate"><span class="pre">UdpEchoServerApplication</span></code> on the node found at index number one of the
<code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code> we used to manage our nodes.  <code class="docutils literal notranslate"><span class="pre">Install</span></code> will return
a container that holds pointers to all of the applications (one in this case
since we passed a <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code> containing one node) created by the
helper.</p>
<p>Applications require a time to “start” generating traffic and may take an
optional time to “stop”.  We provide both.  These times are set using  the
<code class="docutils literal notranslate"><span class="pre">ApplicationContainer</span></code> methods <code class="docutils literal notranslate"><span class="pre">Start</span></code> and <code class="docutils literal notranslate"><span class="pre">Stop</span></code>.  These
methods take <code class="docutils literal notranslate"><span class="pre">Time</span></code> parameters.  In this case, we use an <em>explicit</em>
C++ conversion sequence to take the C++ double 1.0 and convert it to an
<em>ns-3</em> <code class="docutils literal notranslate"><span class="pre">Time</span></code> object using a <code class="docutils literal notranslate"><span class="pre">Seconds</span></code> cast.  Be aware that
the conversion rules may be controlled by the model author, and C++ has its
own rules, so you can’t always just assume that parameters will be happily
converted for you.  The two lines,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">serverApps</span><span class="p">.</span><span class="n">Start</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>
<span class="n">serverApps</span><span class="p">.</span><span class="n">Stop</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">10.0</span><span class="p">));</span>
</pre></div>
</div>
<p>will cause the echo server application to <code class="docutils literal notranslate"><span class="pre">Start</span></code> (enable itself) at one
second into the simulation and to <code class="docutils literal notranslate"><span class="pre">Stop</span></code> (disable itself) at ten seconds
into the simulation.  By virtue of the fact that we have declared a simulation
event (the application stop event) to be executed at ten seconds, the simulation
will last <em>at least</em> ten seconds.</p>
</section>
<section id="udpechoclienthelper">
<h4><span class="section-number">5.2.7.2. </span>UdpEchoClientHelper<a class="headerlink" href="#udpechoclienthelper" title="Link to this heading">¶</a></h4>
<p>The echo client application is set up in a method substantially similar to
that for the server.  There is an underlying <code class="docutils literal notranslate"><span class="pre">UdpEchoClientApplication</span></code>
that is managed by an <code class="docutils literal notranslate"><span class="pre">UdpEchoClientHelper</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">UdpEchoClientHelper</span><span class="w"> </span><span class="nf">echoClient</span><span class="p">(</span><span class="n">interfaces</span><span class="p">.</span><span class="n">GetAddress</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mi">9</span><span class="p">);</span>
<span class="n">echoClient</span><span class="p">.</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;MaxPackets&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="n">echoClient</span><span class="p">.</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;Interval&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TimeValue</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)));</span>
<span class="n">echoClient</span><span class="p">.</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;PacketSize&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">1024</span><span class="p">));</span>

<span class="n">ApplicationContainer</span><span class="w"> </span><span class="n">clientApps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">echoClient</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">nodes</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="n">clientApps</span><span class="p">.</span><span class="n">Start</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">2.0</span><span class="p">));</span>
<span class="n">clientApps</span><span class="p">.</span><span class="n">Stop</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">10.0</span><span class="p">));</span>
</pre></div>
</div>
<p>For the echo client, however, we need to set five different <code class="docutils literal notranslate"><span class="pre">Attributes</span></code>.
The first two <code class="docutils literal notranslate"><span class="pre">Attributes</span></code> are set during construction of the
<code class="docutils literal notranslate"><span class="pre">UdpEchoClientHelper</span></code>.  We pass parameters that are used (internally to
the helper) to set the “RemoteAddress” and “RemotePort” <code class="docutils literal notranslate"><span class="pre">Attributes</span></code>
in accordance with our convention to make required <code class="docutils literal notranslate"><span class="pre">Attributes</span></code> parameters
in the helper constructors.</p>
<p>Recall that we used an <code class="docutils literal notranslate"><span class="pre">Ipv4InterfaceContainer</span></code> to keep track of the IP
addresses we assigned to our devices.  The zeroth interface in the
<code class="docutils literal notranslate"><span class="pre">interfaces</span></code> container is going to correspond to the IP address of the
zeroth node in the <code class="docutils literal notranslate"><span class="pre">nodes</span></code> container.  The first interface in the
<code class="docutils literal notranslate"><span class="pre">interfaces</span></code> container corresponds to the IP address of the first node
in the <code class="docutils literal notranslate"><span class="pre">nodes</span></code> container.  So, in the first line of code (from above), we
are creating the helper and telling it so set the remote address of the client
to be  the IP address assigned to the node on which the server resides.  We
also tell it to arrange to send packets to port nine.</p>
<p>The “MaxPackets” <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> tells the client the maximum number of
packets we allow it to send during the simulation.  The “Interval”
<code class="docutils literal notranslate"><span class="pre">Attribute</span></code> tells the client how long to wait between packets, and the
“PacketSize” <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> tells the client how large its packet payloads
should be.  With this particular combination of <code class="docutils literal notranslate"><span class="pre">Attributes</span></code>, we are
telling the client to send one 1024-byte packet.</p>
<p>Just as in the case of the echo server, we tell the echo client to <code class="docutils literal notranslate"><span class="pre">Start</span></code>
and <code class="docutils literal notranslate"><span class="pre">Stop</span></code>, but here we start the client one second after the server is
enabled (at two seconds into the simulation).</p>
</section>
</section>
<section id="simulator">
<h3><span class="section-number">5.2.8. </span>Simulator<a class="headerlink" href="#simulator" title="Link to this heading">¶</a></h3>
<p>What we need to do at this point is to actually run the simulation.  This is
done using the global function <code class="docutils literal notranslate"><span class="pre">Simulator::Run</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Simulator</span><span class="o">::</span><span class="n">Run</span><span class="p">();</span>
</pre></div>
</div>
<p>When we previously called the methods,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">serverApps</span><span class="p">.</span><span class="n">Start</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>
<span class="n">serverApps</span><span class="p">.</span><span class="n">Stop</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">10.0</span><span class="p">));</span>
<span class="p">...</span>
<span class="n">clientApps</span><span class="p">.</span><span class="n">Start</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">2.0</span><span class="p">));</span>
<span class="n">clientApps</span><span class="p">.</span><span class="n">Stop</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">10.0</span><span class="p">));</span>
</pre></div>
</div>
<p>we actually scheduled events in the simulator at 1.0 seconds, 2.0 seconds and
two events at 10.0 seconds.  When <code class="docutils literal notranslate"><span class="pre">Simulator::Run</span></code> is called, the system
will begin looking through the list of scheduled events and executing them.
First it will run the event at 1.0 seconds, which will enable the echo server
application (this event may, in turn, schedule many other events).  Then it
will run the event scheduled for t=2.0 seconds which will start the echo client
application.  Again, this event may schedule many more events.  The start event
implementation in the echo client application will begin the data transfer phase
of the simulation by sending a packet to the server.</p>
<p>The act of sending the packet to the server will trigger a chain of events
that will be automatically scheduled behind the scenes and which will perform
the mechanics of the packet echo according to the various timing parameters
that we have set in the script.</p>
<p>Eventually, since we only send one packet (recall the <code class="docutils literal notranslate"><span class="pre">MaxPackets</span></code>
<code class="docutils literal notranslate"><span class="pre">Attribute</span></code> was set to one), the chain of events triggered by
that single client echo request will taper off and the simulation will go
idle.  Once this happens, the remaining events will be the <code class="docutils literal notranslate"><span class="pre">Stop</span></code> events
for the server and the client.  When these events are executed, there are
no further events to process and <code class="docutils literal notranslate"><span class="pre">Simulator::Run</span></code> returns.  The simulation
is then complete.</p>
<p>All that remains is to clean up.  This is done by calling the global function
<code class="docutils literal notranslate"><span class="pre">Simulator::Destroy</span></code>.  As the helper functions (or low level
<em>ns-3</em> code) executed, they arranged it so that hooks were inserted in
the simulator to destroy all of the objects that were created.  You did not
have to keep track of any of these objects yourself — all you had to do
was to call <code class="docutils literal notranslate"><span class="pre">Simulator::Destroy</span></code> and exit.  The <em>ns-3</em> system
took care of the hard part for you.  The remaining lines of our first
<em>ns-3</em> script, <code class="docutils literal notranslate"><span class="pre">first.cc</span></code>, do just that:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Destroy</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="when-the-simulator-will-stop">
<h4><span class="section-number">5.2.8.1. </span>When the simulator will stop?<a class="headerlink" href="#when-the-simulator-will-stop" title="Link to this heading">¶</a></h4>
<p><em>ns-3</em> is a Discrete Event (DE) simulator. In such a simulator, each event is
associated with its execution time, and the simulation proceeds by executing
events in the temporal order of simulation time.  Events may cause future
events to be scheduled (for example, a timer may reschedule itself to
expire at the next interval).</p>
<p>The initial events are usually triggered by each object, e.g., IPv6 will
schedule Router Advertisements, Neighbor Solicitations, etc.,
an Application schedule the first packet sending event, etc.</p>
<p>When an event is processed, it may generate zero, one or more events.
As a simulation executes, events are consumed, but more events may (or may
not) be generated.
The simulation will stop automatically when no further events are in the
event queue, or when a special Stop event is found. The Stop event is
created through the
<code class="docutils literal notranslate"><span class="pre">Simulator::Stop(stopTime);</span></code> function.</p>
<p>There is a typical case where <code class="docutils literal notranslate"><span class="pre">Simulator::Stop</span></code> is absolutely necessary
to stop the simulation: when there is a self-sustaining event.
Self-sustaining (or recurring) events are events that always reschedule
themselves. As a consequence, they always keep the event queue non-empty.</p>
<p>There are many protocols and modules containing recurring events, e.g.:</p>
<ul class="simple">
<li><p>FlowMonitor - periodic check for lost packets</p></li>
<li><p>RIPng - periodic broadcast of routing tables update</p></li>
<li><p>etc.</p></li>
</ul>
<p>In these cases, <code class="docutils literal notranslate"><span class="pre">Simulator::Stop</span></code> is necessary to gracefully stop the
simulation.  In addition, when <em>ns-3</em> is in emulation mode, the
<code class="docutils literal notranslate"><span class="pre">RealtimeSimulator</span></code> is used to keep the simulation clock aligned with
the machine clock, and <code class="docutils literal notranslate"><span class="pre">Simulator::Stop</span></code> is necessary to stop the
process.</p>
<p>Many of the simulation programs in the tutorial do not explicitly call
<code class="docutils literal notranslate"><span class="pre">Simulator::Stop</span></code>, since the event queue will automatically run out
of events.  However, these programs will also accept a call to
<code class="docutils literal notranslate"><span class="pre">Simulator::Stop</span></code>.  For example, the following additional statement
in the first example program will schedule an explicit stop at 11 seconds:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">+</span><span class="w">  </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Stop</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">11.0</span><span class="p">));</span>
<span class="w">   </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Run</span><span class="p">();</span>
<span class="w">   </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Destroy</span><span class="p">();</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>The above will not actually change the behavior of this program, since
this particular simulation naturally ends after 10 seconds.  But if you
were to change the stop time in the above statement from 11 seconds to 1
second, you would notice that the simulation stops before any output is
printed to the screen (since the output occurs around time 2 seconds of
simulation time).</p>
<p>It is important to call <code class="docutils literal notranslate"><span class="pre">Simulator::Stop</span></code> <em>before</em> calling
<code class="docutils literal notranslate"><span class="pre">Simulator::Run</span></code>; otherwise, <code class="docutils literal notranslate"><span class="pre">Simulator::Run</span></code> may never return control
to the main program to execute the stop!</p>
</section>
</section>
<section id="building-your-script">
<h3><span class="section-number">5.2.9. </span>Building Your Script<a class="headerlink" href="#building-your-script" title="Link to this heading">¶</a></h3>
<p>We have made it trivial to build your simple scripts.  All you have to do is
to drop your script into the scratch directory and it will automatically be
built if you run ns3.  Let’s try it.  Copy <code class="docutils literal notranslate"><span class="pre">examples/tutorial/first.cc</span></code> into
the <code class="docutils literal notranslate"><span class="pre">scratch</span></code> directory after changing back into the top level directory.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>../..
$<span class="w"> </span>cp<span class="w"> </span>examples/tutorial/first.cc<span class="w"> </span>scratch/myfirst.cc
</pre></div>
</div>
<p>Now build your first example script using ns3:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>build
</pre></div>
</div>
<p>You should see messages reporting that your <code class="docutils literal notranslate"><span class="pre">myfirst</span></code> example was built
successfully.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Scanning<span class="w"> </span>dependencies<span class="w"> </span>of<span class="w"> </span>target<span class="w"> </span>scratch_myfirst
<span class="o">[</span><span class="w">  </span><span class="m">0</span>%<span class="o">]</span><span class="w"> </span>Building<span class="w"> </span>CXX<span class="w"> </span>object<span class="w"> </span>scratch/CMakeFiles/scratch_myfirst.dir/myfirst.cc.o
<span class="o">[</span><span class="w">  </span><span class="m">0</span>%<span class="o">]</span><span class="w"> </span>Linking<span class="w"> </span>CXX<span class="w"> </span>executable<span class="w"> </span>../../build/scratch/ns3.36.1-myfirst-debug
Finished<span class="w"> </span>executing<span class="w"> </span>the<span class="w"> </span>following<span class="w"> </span>commands:
<span class="nb">cd</span><span class="w"> </span>cmake-cache<span class="p">;</span><span class="w"> </span>cmake<span class="w"> </span>--build<span class="w"> </span>.<span class="w"> </span>-j<span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="nb">cd</span><span class="w"> </span>..
</pre></div>
</div>
<p>You can now run the example (note that if you build your program in the scratch
directory you must run it out of the scratch directory):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span>scratch/myfirst
</pre></div>
</div>
<p>You should see some output:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>At<span class="w"> </span><span class="nb">time</span><span class="w"> </span>+2s<span class="w"> </span>client<span class="w"> </span>sent<span class="w"> </span><span class="m">1024</span><span class="w"> </span>bytes<span class="w"> </span>to<span class="w"> </span><span class="m">10</span>.1.1.2<span class="w"> </span>port<span class="w"> </span><span class="m">9</span>
At<span class="w"> </span><span class="nb">time</span><span class="w"> </span>+2.00369s<span class="w"> </span>server<span class="w"> </span>received<span class="w"> </span><span class="m">1024</span><span class="w"> </span>bytes<span class="w"> </span>from<span class="w"> </span><span class="m">10</span>.1.1.1<span class="w"> </span>port<span class="w"> </span><span class="m">49153</span>
At<span class="w"> </span><span class="nb">time</span><span class="w"> </span>+2.00369s<span class="w"> </span>server<span class="w"> </span>sent<span class="w"> </span><span class="m">1024</span><span class="w"> </span>bytes<span class="w"> </span>to<span class="w"> </span><span class="m">10</span>.1.1.1<span class="w"> </span>port<span class="w"> </span><span class="m">49153</span>
At<span class="w"> </span><span class="nb">time</span><span class="w"> </span>+2.00737s<span class="w"> </span>client<span class="w"> </span>received<span class="w"> </span><span class="m">1024</span><span class="w"> </span>bytes<span class="w"> </span>from<span class="w"> </span><span class="m">10</span>.1.1.2<span class="w"> </span>port<span class="w"> </span><span class="m">9</span>
</pre></div>
</div>
<p>Here you see the logging component on the echo client
indicate that it has sent one 1024 byte packet to the Echo Server on
10.1.1.2.  You also see the logging component on the echo server say that
it has received the 1024 bytes from 10.1.1.1.  The echo server silently
echoes the packet and you see the echo client log that it has received its
packet back from the server.</p>
</section>
</section>
<section id="ns-3-source-code">
<h2><span class="section-number">5.3. </span>Ns-3 Source Code<a class="headerlink" href="#ns-3-source-code" title="Link to this heading">¶</a></h2>
<p>Now that you have used some of the <em>ns-3</em> helpers you may want to
have a look at some of the source code that implements that functionality.</p>
<p>Our example scripts are in the <code class="docutils literal notranslate"><span class="pre">examples</span></code> directory.  If you change to <code class="docutils literal notranslate"><span class="pre">examples</span></code> directory,
you will see a list of subdirectories.  One of the files in <code class="docutils literal notranslate"><span class="pre">tutorial</span></code> subdirectory is <code class="docutils literal notranslate"><span class="pre">first.cc</span></code>.  If
you click on <code class="docutils literal notranslate"><span class="pre">first.cc</span></code> you will find the code you just walked through.</p>
<p>The source code is mainly in the <code class="docutils literal notranslate"><span class="pre">src</span></code> directory.  The core of the simulator
is in the <code class="docutils literal notranslate"><span class="pre">src/core/model</span></code> subdirectory.  The first file you will find there
(as of this writing) is <code class="docutils literal notranslate"><span class="pre">abort.h</span></code>.  If you open that file, you can view
macros for exiting scripts if abnormal conditions are detected.</p>
<p>The source code for the helpers we have used in this chapter can be found in the
<code class="docutils literal notranslate"><span class="pre">src/applications/helper</span></code> directory.  Feel free to poke around in the directory tree to
get a feel for what is there and the style of <em>ns-3</em> programs.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">ns-3</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, vishnu.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../_sources/doc/tutorial/source/conceptual-overview.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>