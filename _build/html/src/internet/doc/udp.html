<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>UDP model in ns-3 &#8212; ns-3 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=039e1c02" />
    <script src="../../../_static/documentation_options.js?v=f2a433a1"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="udp-model-in-ns-3">
<h1>UDP model in ns-3<a class="headerlink" href="#udp-model-in-ns-3" title="Link to this heading">¶</a></h1>
<p>This chapter describes the UDP model available in <a href="#id1"><span class="problematic" id="id2">|ns3|</span></a>.</p>
<section id="generic-support-for-udp">
<h2>Generic support for UDP<a class="headerlink" href="#generic-support-for-udp" title="Link to this heading">¶</a></h2>
<p><a href="#id3"><span class="problematic" id="id4">|ns3|</span></a> supports a native implementation of UDP. It provides a connectionless,
unreliable datagram packet service. Packets may be reordered or duplicated before
they arrive. UDP calculates and checks checksums to catch transmission errors.</p>
<p>This implementation inherits from a few common header classes in the <code class="docutils literal notranslate"><span class="pre">src/network</span></code>
directory, so that user code can swap out implementations with minimal changes to
the scripts.</p>
<p>Here are the important abstract base classes:</p>
<ul class="simple">
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">UdpSocket</span></code>: This is defined in:
<code class="docutils literal notranslate"><span class="pre">src/internet/model/udp-socket.{cc,h}</span></code>
This is an abstract base class of all UDP sockets. This class exists solely
for hosting <code class="docutils literal notranslate"><span class="pre">UdpSocket</span></code> attributes that can be reused across different
implementations, and for declaring UDP-specific multicast API.</p></li>
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">UdpSocketImpl</span></code>: This class subclasses <code class="docutils literal notranslate"><span class="pre">UdpSocket</span></code>, and
provides a socket interface to ns-3’s implementation of UDP.</p></li>
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">UdpSocketFactory</span></code>: This is used by the layer-4 protocol
instance to create UDP sockets.</p></li>
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">UdpSocketFactoryImpl</span></code>: This class is derived from <code class="docutils literal notranslate"><span class="pre">SocketFactory</span></code>
and implements the API for creating UDP sockets.</p></li>
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">UdpHeader</span></code>: This class contains fields corresponding to those
in a network UDP header (port numbers, payload size, checksum) as well as methods
for serialization to and deserialization from a byte buffer.</p></li>
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">UdpL4Protocol</span></code>: This is a subclass of <code class="docutils literal notranslate"><span class="pre">IpL4Protocol</span></code> and
provides an implementation of the UDP protocol.</p></li>
</ul>
</section>
<section id="ns-3-udp">
<h2>ns-3 UDP<a class="headerlink" href="#ns-3-udp" title="Link to this heading">¶</a></h2>
<p>This is an implementation of the User Datagram Protocol described in RFC 768.
UDP uses a simple connectionless communication model with a minimum of protocol
mechanism. The implementation provides checksums for data integrity, and port
numbers for addressing different functions at the source and destination of the
datagram. It has no handshaking dialogues, and thus exposes the user’s data to
any unreliability of the underlying network. There is no guarantee of data delivery,
ordering, or duplicate protection.</p>
<section id="usage">
<h3>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h3>
<p>In many cases, usage of UDP is set at the application layer by telling
the <a href="#id5"><span class="problematic" id="id6">|ns3|</span></a> application which kind of socket factory to use.</p>
<p>Using the helper functions defined in <code class="docutils literal notranslate"><span class="pre">src/applications/helper</span></code>, here
is how one would create a UDP receiver:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create a packet sink on the receiver</span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="n">port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">50000</span><span class="p">;</span>
<span class="n">Address</span><span class="w"> </span><span class="nf">sinkLocalAddress</span><span class="p">(</span><span class="n">InetSocketAddress</span><span class="p">(</span><span class="n">Ipv4Address</span><span class="o">::</span><span class="n">GetAny</span><span class="p">(),</span><span class="w"> </span><span class="n">port</span><span class="p">));</span>
<span class="n">PacketSinkHelper</span><span class="w"> </span><span class="n">sinkHelper</span><span class="p">(</span><span class="s">&quot;ns3::UdpSocketFactory&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sinkLocalAddress</span><span class="p">);</span>
<span class="n">ApplicationContainer</span><span class="w"> </span><span class="n">sinkApp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sinkHelper</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">serverNode</span><span class="p">);</span>
<span class="n">sinkApp</span><span class="p">.</span><span class="n">Start</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>
<span class="n">sinkApp</span><span class="p">.</span><span class="n">Stop</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">10.0</span><span class="p">));</span>
</pre></div>
</div>
<p>Similarly, the below snippet configures OnOffApplication traffic source to use
UDP:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create the OnOff applications to send data to the UDP receiver</span>
<span class="n">OnOffHelper</span><span class="w"> </span><span class="n">clientHelper</span><span class="p">(</span><span class="s">&quot;ns3::UdpSocketFactory&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Address</span><span class="p">());</span>
<span class="n">clientHelper</span><span class="p">.</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;Remote&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">remoteAddress</span><span class="p">);</span>
<span class="n">ApplicationContainer</span><span class="w"> </span><span class="n">clientApps</span><span class="w"> </span><span class="o">=</span><span class="p">(</span><span class="n">clientHelper</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">clientNode</span><span class="p">);</span>
<span class="n">clientApps</span><span class="p">.</span><span class="n">Start</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">2.0</span><span class="p">));</span>
<span class="n">clientApps</span><span class="p">.</span><span class="n">Stop</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">9.0</span><span class="p">));</span>
</pre></div>
</div>
<p>For users who wish to have a pointer to the actual socket(so that
socket operations like <code class="docutils literal notranslate"><span class="pre">Bind()</span></code>, setting socket options, etc. can be
done on a per-socket basis), UDP sockets can be created by using the
<code class="docutils literal notranslate"><span class="pre">Socket::CreateSocket()</span></code> method as given below:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">InternetStackHelper</span><span class="w"> </span><span class="n">internet</span><span class="p">;</span>
<span class="n">internet</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">SocketFactory</span><span class="o">&gt;</span><span class="w"> </span><span class="n">socketFactory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">UdpSocketFactory</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Socket</span><span class="o">&gt;</span><span class="w"> </span><span class="n">socket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socketFactory</span><span class="o">-&gt;</span><span class="n">CreateSocket</span><span class="p">();</span>
<span class="n">socket</span><span class="o">-&gt;</span><span class="n">Bind</span><span class="p">(</span><span class="n">InetSocketAddress</span><span class="p">(</span><span class="n">Ipv4Address</span><span class="o">::</span><span class="n">GetAny</span><span class="p">(),</span><span class="w"> </span><span class="mi">80</span><span class="p">));</span>
</pre></div>
</div>
<p>Once a UDP socket is created, we do not need an explicit connection setup before
sending and receiving data. Being a connectionless protocol, all we need to do
is to create a socket and bind it to a known port. For a client, simply create a
socket and start sending data. The <code class="docutils literal notranslate"><span class="pre">Bind()</span></code> call allows an application to specify
a port number and an address on the local machine. It allocates a local IPv4
endpoint for this socket.</p>
<p>At the end of data transmission, the socket is closed using the <code class="docutils literal notranslate"><span class="pre">Socket::Close()</span></code>.
It returns a 0 on success and -1 on failure.</p>
<p>Please note that applications usually create the sockets automatically. Please
refer to the source code of your preferred application to discover how and
when it creates the socket.</p>
<section id="udp-socket-interaction-and-interface-with-application-layer">
<h4>UDP Socket interaction and interface with Application layer<a class="headerlink" href="#udp-socket-interaction-and-interface-with-application-layer" title="Link to this heading">¶</a></h4>
<p>The following is the description of the public interface of the UDP socket,
and how the interface is used to interact with the socket itself.</p>
<p><strong>Socket APIs for UDP connections</strong>:</p>
<dl class="simple">
<dt><em>Connect()</em></dt><dd><p>This is called when <code class="docutils literal notranslate"><span class="pre">Send()</span></code> is used instead of <code class="docutils literal notranslate"><span class="pre">SendTo()</span></code> by the user.
It sets the address of the remote endpoint which is used by <code class="docutils literal notranslate"><span class="pre">Send()</span></code>. If the
remote address is valid, this method makes a callback to <em>ConnectionSucceeded</em>.</p>
</dd>
<dt><em>Bind()</em></dt><dd><p>Bind the socket to an address, or to a general endpoint. A general endpoint
is an endpoint with an ephemeral port allocation (that is, a random port
allocation) on the 0.0.0.0 IP address. For instance, in current applications,
data senders usually bind automatically after a <code class="docutils literal notranslate"><span class="pre">Connect()</span></code> over a random
port. Consequently, the connection will start from this random port towards
the well-defined port of the receiver. The IP 0.0.0.0 is then translated by
lower layers into the real IP of the device.</p>
</dd>
<dt><em>Bind6()</em></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">Bind()</span></code>, but for IPv6.</p>
</dd>
<dt><em>BindToNetDevice()</em></dt><dd><p>Bind the socket to the specified <code class="docutils literal notranslate"><span class="pre">NetDevice</span></code>. If set on a socket, this option
will force packets to leave the bound device regardless of the device that IP
routing would naturally choose. In the receive direction, only packets received
from the bound interface will be delivered.</p>
</dd>
<dt><em>ShutdownSend()</em></dt><dd><p>Signals the termination of send, or in other words, prevents data from being added
to the buffer.</p>
</dd>
<dt><em>Recv()</em></dt><dd><p>Grabs data from the UDP socket and forwards it to the application layer. If no
data is present (i.e. <code class="docutils literal notranslate"><span class="pre">m_deliveryQueue.empty()</span></code> returns 0), an empty packet is
returned.</p>
</dd>
<dt><em>RecvFrom()</em></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">Recv()</span></code>, but with the source address as parameter.</p>
</dd>
<dt><em>SendTo()</em></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">SendTo()</span></code> API is the UDP counterpart of the TCP API <code class="docutils literal notranslate"><span class="pre">Send()</span></code>. It
additionally specifies the address to which the message is to be sent
because no prior connection is established in UDP communication. It returns
the number of bytes sent or -1 in case of failure.</p>
</dd>
<dt><em>Close()</em></dt><dd><p>The close API closes a socket and terminates the connection. This
results in freeing all the data structures previously allocated.</p>
</dd>
</dl>
<hr class="docutils" />
<p><strong>Public callbacks</strong></p>
<p>These callbacks are called by the UDP socket to notify the application of
interesting events. We will refer to these with the protected name used in
<code class="docutils literal notranslate"><span class="pre">socket.h</span></code>, but we will provide the API function to set the pointers to these
callback as well.</p>
<dl class="simple">
<dt><em>NotifyConnectionSucceeded</em>: <em>SetConnectCallback</em>, 1st argument</dt><dd><p>Called when the <code class="docutils literal notranslate"><span class="pre">Connect()</span></code> succeeds and the remote address is validated.</p>
</dd>
<dt><em>NotifyConnectionFailed</em>: <em>SetConnectCallback</em>, 2nd argument</dt><dd><p>Called in <code class="docutils literal notranslate"><span class="pre">Connect()</span></code> when the the remote address validation fails.</p>
</dd>
<dt><em>NotifyDataSent</em>: <em>SetDataSentCallback</em></dt><dd><p>The socket notifies the application that some bytes have been transmitted at
the IP layer. These bytes could still be lost in the node (traffic control
layer) or in the network.</p>
</dd>
<dt><em>NotifySend</em>: <em>SetSendCallback</em></dt><dd><p>Invoked to get the space available in the tx buffer when a packet (that carries
data) is sent.</p>
</dd>
<dt><em>NotifyDataRecv</em>: <em>SetRecvCallback</em></dt><dd><p>Called when the socket receives a packet (that carries data) in the receiver
buffer.</p>
</dd>
</dl>
</section>
</section>
<section id="validation">
<h3>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h3>
<p>The following test cases have been provided for UDP implementation in the
<code class="docutils literal notranslate"><span class="pre">src/internet/test/udp-test.cc</span></code> file.</p>
<ul class="simple">
<li><p><strong>UdpSocketImplTest:</strong> Checks data received via UDP Socket over IPv4.</p></li>
<li><p><strong>UdpSocketLoopbackTest:</strong> Checks data received via UDP Socket Loopback over IPv4.</p></li>
<li><p><strong>Udp6SocketImplTest :</strong> Checks data received via UDP Socket over IPv6.</p></li>
<li><p><strong>Udp6SocketLoopbackTest :</strong> Checks data received via UDP Socket Loopback over IPv6 Test.</p></li>
</ul>
</section>
<section id="limitations">
<h3>Limitations<a class="headerlink" href="#limitations" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>UDP_CORK is presently not the part of this implementation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NotifyNormalClose</span></code>, <code class="docutils literal notranslate"><span class="pre">NotifyErrorClose</span></code>, <code class="docutils literal notranslate"><span class="pre">NotifyConnectionRequest</span></code> and
<code class="docutils literal notranslate"><span class="pre">NotifyNewConnectionCreated</span></code> socket API callbacks are not supported.</p></li>
</ul>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">ns-3</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, vishnu.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../_sources/src/internet/doc/udp.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>