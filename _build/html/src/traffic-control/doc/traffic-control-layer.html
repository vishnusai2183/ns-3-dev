<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Traffic Control Layer &#8212; ns-3 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=039e1c02" />
    <script src="../../../_static/documentation_options.js?v=f2a433a1"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="traffic-control-layer">
<h1>Traffic Control Layer<a class="headerlink" href="#traffic-control-layer" title="Link to this heading">¶</a></h1>
<p>The Traffic Control layer aims at introducing an equivalent of the Linux Traffic
Control infrastructure into ns-3. The Traffic Control layer sits in between
the NetDevices (L2) and any network protocol (e.g. IP). It is in charge of processing
packets and performing actions on them: scheduling, dropping, marking, policing, etc.</p>
<section id="introducing-the-traffic-control-layer">
<h2>Introducing the Traffic Control Layer<a class="headerlink" href="#introducing-the-traffic-control-layer" title="Link to this heading">¶</a></h2>
<p>The Traffic Control layer intercepts both outgoing packets flowing downwards from
the network layer to the network device and incoming packets flowing in the opposite
direction. Currently, only outgoing packets are processed by the Traffic Control layer.
In particular, outgoing packets are enqueued in a queuing discipline, which can perform
multiple actions on them.</p>
<p>In the following, more details are given about how the Traffic Control layer intercepts
outgoing and incoming packets and, more in general, about how the packets traverse the
network stack.</p>
<section id="transmitting-packets">
<h3>Transmitting packets<a class="headerlink" href="#transmitting-packets" title="Link to this heading">¶</a></h3>
<p>The IPv{4,6} interfaces uses the aggregated object TrafficControlLayer to send
down packets, instead of calling NetDevice::Send() directly. After the analysis
and the process of the packet, when the backpressure mechanism allows it,
TrafficControlLayer will call the Send() method on the right NetDevice.</p>
</section>
<section id="receiving-packets">
<h3>Receiving packets<a class="headerlink" href="#receiving-packets" title="Link to this heading">¶</a></h3>
<p>The callback chain that (in the past) involved IPv{4,6}L3Protocol and NetDevices,
through ReceiveCallback, is extended to involve TrafficControlLayer. When an
IPv{4,6}Interface is added in the IPv{4,6}L3Protocol, the callback chain is
configured to have the following packet exchange:</p>
<p>NetDevice –&gt; Node –&gt; TrafficControlLayer –&gt; IPv{4,6}L3Protocol</p>
</section>
</section>
<section id="brief-description-of-old-node-device-protocol-interactions">
<h2>Brief description of old node/device/protocol interactions<a class="headerlink" href="#brief-description-of-old-node-device-protocol-interactions" title="Link to this heading">¶</a></h2>
<p>The main question that we would like to answer in the following paragraphs is:
how a ns-3 node can send/receive packets?</p>
<p>If we analyze any example out there, the ability of the node to receive/transmit
packets derives from the interaction of two helper:</p>
<ul class="simple">
<li><p>L2 Helper (something derived from NetDevice)</p></li>
<li><p>L3 Helper (usually from Internet module)</p></li>
</ul>
<section id="l2-helper-main-operations">
<h3>L2 Helper main operations<a class="headerlink" href="#l2-helper-main-operations" title="Link to this heading">¶</a></h3>
<p>Any good L2 Helper will do the following operations:</p>
<ul class="simple">
<li><p>Create n netdevices (n&gt;1)</p></li>
<li><p>Attach a channel between these devices</p></li>
<li><p>Call Node::AddDevice ()</p></li>
</ul>
<p>Obviously the last point is the most important.</p>
<p>Node::AddDevice (network/model/node.cc:128) assigns an interface index to the
device, calls NetDevice::SetNode, sets the receive callback of the device to
Node::NonPromiscReceiveFromDevice. Then, it schedules NetDevice::Initialize() method at
Seconds(0.0), then notify the registered DeviceAdditionListener handlers (not used BY ANYONE).</p>
<p>Node::NonPromiscReceiveFromDevice calls Node::ReceiveFromDevice.</p>
<p>Node::ReceiveFromDevice iterates through ProtocolHandlers, which are callbacks
which accept as signature:</p>
<p>ProtocolHandler (Ptr&lt;NetDevice&gt;, Ptr&lt;const Packet&gt;, protocol, from_addr, to_addr, packetType).</p>
<p>If device, protocol number and promiscuous flag corresponds, the handler is
invoked.</p>
<p>Who is responsible to set ProtocolHandler ? We will analyze that in the next
section.</p>
</section>
<section id="l3-helper">
<h3>L3 Helper<a class="headerlink" href="#l3-helper" title="Link to this heading">¶</a></h3>
<p>We have only internet which provides network protocol (IP). That module splits
the operations between two helpers: InternetStackHelper and Ipv{4,6}AddressHelper.</p>
<p>InternetStackHelper::Install (internet/helper/internet-stack-helper.cc:423)
creates and aggregates protocols {ArpL3,Ipv4L3,Icmpv4}Protocol. It creates the
routing protocol, and if Ipv6 is enabled it adds {Ipv6L3,Icmpv6L4}Protocol. In
any case, it instantiates and aggregates an UdpL4Protocol object, along with a
PacketSocketFactory.
Ultimately, it creates the required objects and aggregates them to the node.</p>
<p>Let’s assume an Ipv4 environment (things are the same for Ipv6).</p>
<p>Ipv4AddressHelper::Assign (src/internet/helper/ipv4-address-helper.cc:131)
registers the handlers. The process is a bit long. The method is called with
a list of NetDevice. For each of them, the node and Ipv4L3Protocol pointers are
retrieved; if an Ipv4Interface is already registered for the device, on that the
address is set. Otherwise, the method Ipv4L3Protocol::AddInterface is called,
before adding the address.</p>
</section>
<section id="ip-interfaces">
<h3>IP interfaces<a class="headerlink" href="#ip-interfaces" title="Link to this heading">¶</a></h3>
<p>In Ipv4L3Protocol::AddInterface (src/internet/model/ipv4-l3-protocol.cc:300)
two protocol handlers are installed: one that react to ipv4 protocol number,
and one that react to arp protocol number (Ipv4L3Protocol::Receive and
ArpL3Protocol::Receive, respectively). The interface is then created,
initialized, and returned.</p>
<p>Ipv4L3Protocol::Receive (src/internet/model/ipv4-l3-protocol.cc:472) iterates
through the interface. Once it finds the Ipv4Interface which has the same device
as the one passed as argument, invokes the rxTrace callback. If the interface is
down, the packet is dropped. Then, it removes the header and trim any residual
frame padding. If checksum is not OK, it drops the packet. Otherwise, forward
the packet to the raw sockets (not used). Then, it ask the routing protocol what
is the destiny of that packet. The choices are: Ipv4L3Protocol::{IpForward,
IpMulticastForward,LocalDeliver,RouteInputError}.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">ns-3</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, vishnu.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../_sources/src/traffic-control/doc/traffic-control-layer.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>